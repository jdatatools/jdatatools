<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.ainouss.datatools</groupId>
        <artifactId>jdatatools-parent</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>

    <artifactId>jdatatools-query</artifactId>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
        </dependency>
        <dependency>
            <groupId>jakarta.persistence</groupId>
            <artifactId>jakarta.persistence-api</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-collections4</artifactId>
        </dependency>
    </dependencies>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>${maven-compiler-plugin.version}</version>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
package com.ainouss.jdatatools.query.choice;

import com.ainouss.jdatatools.query.core.Alias;
import com.ainouss.jdatatools.query.core.Fragment;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

import java.util.ArrayList;
import java.util.List;

public abstract class Case extends Alias implements Selectable {

    protected Fragment attribute;
    protected final List<WhenThen> whenThens = new ArrayList<>();
    protected Fragment otherwise;
    private final SqlDialect sqlDialect;

    public Case(SqlDialect sqlDialect) {
        this.sqlDialect = sqlDialect;
    }

    public Case() { // For CTE - default constructor
        this(null);
    }


    @Override
    public String toSql() {
        StringBuilder sql = new StringBuilder("case ");
        if (attribute != null) {
            sql.append(attribute.toSql()).append(" "); // Searched CASE
        }

        for (WhenThen whenThen : whenThens) {
            sql.append("when ").append(whenThen.getWhen().toSql())
                    .append(" then ").append(whenThen.getThen().toSql()).append(" ");
        }

        if (otherwise != null) {
            sql.append("else ").append(otherwise.toSql()).append(" ");
        }

        sql.append("end");
        return sql.toString();
    }

    public Selectable end() {
        return this;
    }
}
package com.ainouss.jdatatools.query.choice;


import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.LiteralValue;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

public class SearchedCase extends Case {

    private final SqlDialect sqlDialect;

    public SearchedCase(SqlDialect sqlDialect) {
        super(sqlDialect);
        this.sqlDialect = sqlDialect;
    }

    public SearchedCase() { // For CTE - default constructor
        this(null);
    }


    public SearchedWhen when(Expression expression) {
        WhenThen whenThen = new WhenThen(expression);
        whenThens.add(whenThen);
        return new SearchedWhen(this, whenThen, sqlDialect);
    }

    public SearchedCase whenThen(Expression expression, Object then) {
        WhenThen whenThen = new WhenThen(expression);
        whenThen.setThen(new LiteralValue(then));
        whenThens.add(whenThen);
        return this;
    }

    public SearchedCase otherwise(Object obj) {
        this.otherwise = new LiteralValue(obj);
        return this;
    }
}
package com.ainouss.jdatatools.query.choice;

import com.ainouss.jdatatools.query.core.LiteralValue;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

public class SearchedWhen {

    private final WhenThen whenThen;
    private final SearchedCase caseExpression;
    private final SqlDialect sqlDialect;

    public SearchedWhen(SearchedCase choice, WhenThen whenThen, SqlDialect sqlDialect) {
        this.whenThen = whenThen;
        this.caseExpression = choice;
        this.sqlDialect = sqlDialect;
    }

    public SearchedCase then(Object obj) {
        Selectable then = new LiteralValue(obj);
        whenThen.setThen(then);
        return caseExpression;
    }
}
package com.ainouss.jdatatools.query.choice;


import com.ainouss.jdatatools.query.core.LiteralValue;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.core.SelectableExpression;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

public class SimpleCase extends Case {

    private final SqlDialect sqlDialect;

    public SimpleCase(Selectable attribute, SqlDialect sqlDialect) {
        super(sqlDialect);
        this.attribute = attribute;
        this.sqlDialect = sqlDialect;
    }

    public SimpleCase() { // For CTE - default constructor
        this(null, null);
    }
    public SimpleCase(SqlDialect sqlDialect) { // For CriteriaBuilder default constructor
        this(null, sqlDialect);
    }


    public SimpleWhen when(Object val) {
        SelectableExpression when = new SelectableExpression(new LiteralValue(val));
        WhenThen whenThen = new WhenThen(when);
        whenThens.add(whenThen);
        return new SimpleWhen(this, whenThen);
    }

    public SimpleCase whenThen(Object when, Object obj) {
        WhenThen whenThen = new WhenThen(new SelectableExpression(new LiteralValue(when)));
        whenThen.setThen(new LiteralValue(obj));
        whenThens.add(whenThen);
        return this;
    }

    public SimpleCase otherwise(Object obj) {
        this.otherwise = new LiteralValue(obj);
        return this;
    }
}
package com.ainouss.jdatatools.query.choice;

import com.ainouss.jdatatools.query.core.LiteralValue;
import com.ainouss.jdatatools.query.core.Selectable;

public class SimpleWhen {

    private final WhenThen whenThen;
    private final SimpleCase caseExpression;

    public SimpleWhen(SimpleCase caseExpression, WhenThen whenThen) {
        this.whenThen = whenThen;
        this.caseExpression = caseExpression;
    }

    public SimpleCase then(Object obj) {
        Selectable then = new LiteralValue(obj);
        whenThen.setThen(then);
        return caseExpression;
    }
}
package com.ainouss.jdatatools.query.choice;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.Selectable;
import lombok.Data;

@Data
public class WhenThen {

    private final Expression when;
    private Selectable then;

    WhenThen(Expression when) {
        this.when = when;
    }


}
package com.ainouss.jdatatools.query.core;

import com.ainouss.jdatatools.query.util.DataUtils;

public abstract class Alias implements WithAlias {

    protected String alias;

    @Override
    public void setAlias(String alias) {
        this.alias = alias;
    }

    @Override
    public String getAlias() {
        return DataUtils.trimToBlank(alias);
    }
}

package com.ainouss.jdatatools.query.core;

import com.ainouss.jdatatools.query.choice.SearchedCase;
import com.ainouss.jdatatools.query.choice.SimpleCase;
import com.ainouss.jdatatools.query.dialect.SqlDialect;
import com.ainouss.jdatatools.query.dialect.StandardDialect;
import com.ainouss.jdatatools.query.function.*;
import com.ainouss.jdatatools.query.logical.AbstractExpression;
import com.ainouss.jdatatools.query.logical.And;
import com.ainouss.jdatatools.query.logical.Not;
import com.ainouss.jdatatools.query.logical.Or;
import com.ainouss.jdatatools.query.operator.*;
import com.ainouss.jdatatools.query.subquery.All;
import com.ainouss.jdatatools.query.subquery.Any;
import com.ainouss.jdatatools.query.subquery.Exists;

import java.util.Arrays;
import java.util.List;

/**
 * Used to construct criteria queries, selections, expressions, predicates, orderings.
 */
public class CriteriaBuilder {
    private final SqlDialect sqlDialect;

    public CriteriaBuilder(SqlDialect sqlDialect) {
        this.sqlDialect = sqlDialect;
    }

    public CriteriaBuilder() {
        this(new StandardDialect()); // Default to standard SQL if no dialect is specified
    }

    public SqlDialect getSqlDialect() {
        return sqlDialect;
    }

    /**
     * @param clazz class
     * @param <T>   type
     * @return new CriteriaQuery
     */
    public <T> CriteriaQuery<T> createQuery(Class<T> clazz) {
        return new CriteriaQuery<>(clazz, this);
    }

    public <T> ScalarQuery<T> scalar(CriteriaQuery<T> cr) {
        return new ScalarQuery<>(cr);
    }


    public Expression like(Selectable attribute, Object value) {
        if (value instanceof Selectable selectable) {
            return new Like(attribute, selectable, sqlDialect);
        }
        return new Like(attribute, new LiteralValue(value), sqlDialect);
    }

    public Expression endsWith(Selectable attribute, Object exp) {
        if (exp instanceof Selectable selectable) {
            return new EndsWith(attribute, selectable, sqlDialect);
        }
        return new EndsWith(attribute, new LiteralValue(exp), sqlDialect);
    }

    public Expression startsWith(Selectable attribute, Object exp) {
        if (exp instanceof Selectable selectable) {
            return new StartsWith(attribute, selectable, sqlDialect);
        }
        return new StartsWith(attribute, new LiteralValue(exp), sqlDialect);
    }

    public Expression eq(Selectable attribute, Object value) {
        if (value instanceof Selectable selectable) {
            return new Eq(attribute, selectable, sqlDialect);
        }
        return new Eq(attribute, new LiteralValue(value), sqlDialect);
    }


    public Expression ne(Selectable attribute, Object value) {
        if (value instanceof Selectable selectable) {
            return new Ne(attribute, selectable, sqlDialect);
        }
        return new Ne(attribute, new LiteralValue(value), sqlDialect);
    }

    public Expression gt(Selectable attribute, Object value) {
        if (value instanceof Selectable selectable) {
            return new Gt(attribute, selectable, sqlDialect);
        }
        return new Gt(attribute, new LiteralValue(value), sqlDialect);
    }


    public Expression lt(Selectable attribute, Object value) {
        if (value instanceof Selectable selectable) {
            return new Lt(attribute, selectable, sqlDialect);
        }
        return new Lt(attribute, new LiteralValue(value), sqlDialect);
    }

    public Expression le(Selectable attribute, Object value) {
        if (value instanceof Selectable selectable) {
            return new Le(attribute, selectable, sqlDialect);
        }
        return new Le(attribute, new LiteralValue(value), sqlDialect);
    }

    public Expression ge(Selectable attribute, Object value) {
        if (value instanceof Selectable selectable) {
            return new Ge(attribute, selectable, sqlDialect);
        }
        return new Ge(attribute, new LiteralValue(value), sqlDialect);
    }

    public Expression in(Selectable attribute, Object... values) {
        if (values == null || values.length == 0) {
            throw new IllegalArgumentException("values must not be null or empty");
        }
        List<Selectable> list = Arrays.stream(values)
                .map(o -> o instanceof Selectable ? (Selectable) o : new LiteralValue(o))
                .toList();
        return new In(attribute, list, sqlDialect);
    }

    public Expression inL(Selectable attribute, List<?> values) {
        if (values == null || values.isEmpty()) {
            throw new IllegalArgumentException("values must not be null or empty");
        }
        List<Selectable> list = values.stream()
                .map(o -> o instanceof Selectable ? (Selectable) o : new LiteralValue(o))
                .toList();
        return new In(attribute, list, sqlDialect);
    }

    /**
     * In with a nullable or empty collection of parameters
     * if the collection is empty, an IdentityExpression is returned
     *
     * @param values nullable in values
     * @return expression
     */
    public Expression inn(Selectable attribute, List<?> values) {
        if (values == null || values.isEmpty()) {
            return new EmptyExpression();
        }
        List<Selectable> list = values.stream()
                .map(o -> o instanceof Selectable ? (Selectable) o : new LiteralValue(o))
                .toList();
        return new In(attribute, list, sqlDialect);
    }

    public Expression between(Selectable attribute, Object exp1, Object exp2) {
        return new Bt(attribute, new LiteralValue(exp1), new LiteralValue(exp2), sqlDialect);
    }

    /**
     * Is not null expression
     *
     * @param path path
     * @return is not null
     */
    public Expression isNotNull(Path<?> path) {
        return new IsNotNull(path, sqlDialect);
    }

    /**
     * Is null
     *
     * @param path path
     * @return is null
     */

    public Expression isNull(Path<?> path) {
        return new IsNull(path, sqlDialect);
    }

    /**
     * And expression
     *
     * @param expression  expression
     * @param expressions other expressions
     * @return combined expressions with AND operator
     */
    public AbstractExpression and(Expression expression, Expression... expressions) {
        And and = new And(expression, sqlDialect);
        and.and(expressions);
        return and;
    }

    /**
     * Or expression
     *
     * @param expression  expression
     * @param expressions other expressions
     * @return combined expressions with OR operator
     */
    public AbstractExpression or(Expression expression, Expression... expressions) {
        Or or = new Or(expression, sqlDialect);
        or.or(expressions);
        return or;
    }

    /**
     * NOT expressions
     *
     * @param expressions other expressions
     * @return combined expressions with OR operator
     */
    public Expression not(Expression expression, Expression... expressions) {
        Expression and = new And(expression, sqlDialect).and(expressions);
        return new Not(and, sqlDialect);
    }

    /**
     * Max expression
     *
     * @return max(attribute)
     */
    public Selectable max(Selectable selectable) {
        return new Max(selectable, sqlDialect);
    }

    /**
     * Min expression
     *
     * @return min(attribute)
     */
    public Aggregable min(Selectable selectable) {
        return new Min(selectable, sqlDialect);
    }


    /**
     * Avg expression
     *
     * @param selectable attribute
     * @return avg(attribute)
     */
    public Aggregable sum(Selectable selectable) {
        return new Sum(selectable, sqlDialect);
    }

    public Aggregable rank() {
        return new Rank(sqlDialect);
    }

    public Aggregable rowNumber() {
        return new RowNumber(sqlDialect);
    }


    /**
     * Avg expression
     *
     * @param selectable attribute
     * @return avg(attribute)
     */
    public Aggregable avg(Selectable selectable) {
        return new Avg(selectable, sqlDialect);
    }

    /**
     * Count expression
     *
     * @return count(attribute)
     */
    public Aggregable count(Selectable selectable) {
        return new Count(selectable, sqlDialect);
    }

    /**
     * distinct expression
     *
     * @return distinct(attribute)
     */
    public Selectable distinct(Selectable selectable) {
        return new Distinct(selectable, sqlDialect);
    }


    /**
     * EXISTS subquery
     *
     * @param subquery subquery
     * @return EXISTS expression
     */
    public Expression exists(CriteriaQuery<?> subquery) {
        return new Exists(subquery, sqlDialect);
    }

    /**
     * ANY subquery
     *
     * @param subquery subquery
     * @return 'ANY' expression
     */
    public Expression any(CriteriaQuery<?> subquery) {
        return new Any(subquery, sqlDialect);
    }

    /**
     * ALL subquery
     *
     * @param subquery subquery
     * @return 'ALL' expression
     */
    public Expression all(CriteriaQuery<?> subquery) {
        return new All(subquery, sqlDialect);
    }


    public SimpleCase choice(Selectable attribute) {
        return new SimpleCase(attribute, sqlDialect);
    }

    public SearchedCase choice() {
        return new SearchedCase(sqlDialect);
    }

    public <T> Cte<T> with(String name) {
        return new Cte<>(name, sqlDialect);
    }
}
package com.ainouss.jdatatools.query.core;

import com.ainouss.jdatatools.query.dialect.SqlDialect;
import com.ainouss.jdatatools.query.join.Join;
import com.ainouss.jdatatools.query.order.Order;
import com.ainouss.jdatatools.query.order.OrderDirection;
import com.ainouss.jdatatools.query.registery.EntityRegistry;
import com.ainouss.jdatatools.query.setoperation.*;
import lombok.Getter;

import java.lang.reflect.Field;
import java.util.*;
import java.util.stream.Collectors;

import static com.ainouss.jdatatools.query.registery.EntityRegistry.fullResolve;
import static com.ainouss.jdatatools.query.util.DataUtils.defaultIfEmpty;
import static com.ainouss.jdatatools.query.util.DataUtils.isNotBlank;


/**
 * Criteria query builder. This class provides a fluent API for constructing SQL queries
 * in a type-safe manner. It supports various operations such as selecting columns,
 * filtering data with where clauses, joining tables, ordering results, and grouping.
 *
 * @param <T> The type of the entity being queried.
 */
public class CriteriaQuery<T> {

    @Getter
    protected Class<T> resultType;
    protected final LinkedHashSet<Selectable> selections = new LinkedHashSet<>();
    protected final LinkedHashSet<Source> froms = new LinkedHashSet<>();
    protected final SimpleExpression where;
    protected final SimpleExpression having;
    protected final LinkedHashSet<Order> orderBy = new LinkedHashSet<>();
    protected final List<Join<?, ?>> joins = new ArrayList<>();
    protected final LinkedHashSet<Expression> groupBy = new LinkedHashSet<>();
    protected final List<SetOperation> unions = new ArrayList<>();
    protected final Pagination pagination;
    private final CriteriaBuilder criteriaBuilder;

    /**
     * Constructs a new {@code CriteriaQuery} instance.
     * <p>
     * Note: This constructor does not resolve annotations automatically.
     * A map of paths should be provided for annotation resolution.
     *
     * @param javaType The Java class of the entity being queried.
     */
    CriteriaQuery(Class<T> javaType, CriteriaBuilder criteriaBuilder) {
        EntityRegistry.registerClass(javaType);
        this.resultType = javaType;
        this.criteriaBuilder = criteriaBuilder;
        this.where = new SimpleExpression(criteriaBuilder.getSqlDialect());
        this.having = new SimpleExpression(criteriaBuilder.getSqlDialect());// Dialect Integration
        this.pagination = new Pagination(criteriaBuilder.getSqlDialect());
    }

    protected CriteriaQuery() {
        // For CTEs - no dialect initially, dialect will be inherited from root query
        this.criteriaBuilder = null; // CTEs don't have a CriteriaBuilder initially
        this.where = new SimpleExpression();
        this.having = new SimpleExpression();
        this.pagination = new Pagination();
    }


    public CriteriaQuery<T> from(Source source, Source... sources) {
        if (source == null && sources == null) {
            throw new RuntimeException("no source specified");
        }
        this.froms.clear();
        this.froms.add(source);
        if (sources != null) {
            this.froms.addAll(Arrays.asList(sources));
        }

        return this;
    }

    /**
     * Selects multiple attributes or expressions.
     *
     * @param selectables The paths representing the attributes or expressions to select.
     * @return This {@code CriteriaQuery} instance for method chaining.
     */
    public final CriteriaQuery<T> select(Selectable... selectables) {
        if (selectables == null) {
            return this;
        }
        selections.clear();
        var list = Arrays.stream(selectables)
                .toList();
        selections.addAll(list);
        return this;
    }

    /**
     * Selects all columns from the specified root entity.
     *
     * @param selected The root entity from which to select all columns.
     * @return This {@code CriteriaQuery} instance for method chaining.
     */
    public final CriteriaQuery<T> select(Source selected) {
        var select = EntityRegistry.paths.keySet()
                .stream()
                .filter(path -> path.head.equals(selected))
                .peek(path -> path.head.as(selected.getAlias()))
                .toList();
        this.selections.addAll(select);
        return this;
    }


    /**
     * Overloads the root object with a new entity type.
     *
     * @param from The Java class of the new root entity.
     * @param <R>  The type of the new root entity.
     * @return The new root object.
     */
    public <R> Root<R> from(Class<R> from) {
        EntityRegistry.registerClass(from);
        Root<R> root = new Root<>(from);
        this.froms.add(root);
        return root;
    }

    /**
     * Sets the root object without modifying the existing root.
     *
     * @param from The new root object.
     * @return This {@code CriteriaQuery} instance for method chaining.
     */
    public CriteriaQuery<T> from(Root<?> from) {
        this.froms.add(from);
        return this;
    }


    private String froms() {
        return froms.stream()
                .map(from -> from.getName() + " " + from.getAlias())
                .collect(Collectors.joining(","));
    }

    private String into() {
        return froms.stream()
                .map(Source::getName)
                .collect(Collectors.joining(","));
    }

    /**
     * Adds a where clause to the query.
     *
     * @param expression The expression for the where clause.
     * @return This {@code CriteriaQuery} instance for method chaining.
     */
    public CriteriaQuery<T> where(Expression expression) {
        this.where.with(expression);
        return this;
    }

    /**
     * Adds an order by clause to the query.
     *
     * @param path  The attribute representing the attribute to order by.
     * @param order The order direction (ascending or descending).
     * @return This {@code CriteriaQuery} instance for method chaining.
     */
    public CriteriaQuery<T> orderBy(Selectable path, OrderDirection order) {
        this.orderBy.add(new Order(path, order));
        return this;
    }

    /**
     * Adds a Having clause to the query.
     *
     * @return This {@code CriteriaQuery} instance for method chaining.
     */
    public CriteriaQuery<T> having(Expression expression) {
        this.having.with(expression);
        return this;
    }

    /**
     * Adds an order by clause to the query with the default ascending order.
     *
     * @param path The path representing the attribute to order by.
     * @return This {@code CriteriaQuery} instance for method chaining.
     */
    public CriteriaQuery<T> orderBy(Path<?> path) {
        this.orderBy.add(new Order(path));
        return this;
    }

    public CriteriaQuery<T> orderBy(Order... orders) {
        if (orders == null) {
            return this;
        }
        this.orderBy.addAll(Arrays.asList(orders));
        return this;
    }

    /**
     * Adds a group by clause to the query.
     *
     * @param expression The path representing the attribute to group by.
     * @return This {@code CriteriaQuery} instance for method chaining.
     */
    public CriteriaQuery<T> groupBy(Expression expression) {
        this.groupBy.add(expression);
        return this;
    }

    public CriteriaQuery<T> limit(Integer limit) {
        this.pagination.setLimit(limit);
        return this;
    }

    public CriteriaQuery<T> offset(Integer offset) {
        this.pagination.setOffset(offset);
        return this;
    }

    public CriteriaQuery<T> union(CriteriaQuery<?> other) {
        this.unions.add(new Union(other));
        return this;
    }

    public CriteriaQuery<T> unionAll(CriteriaQuery<?> other) {
        this.unions.add(new UnionAll(other));
        return this;
    }

    public CriteriaQuery<T> intersect(CriteriaQuery<?> other) {
        this.unions.add(new Intersect(other));
        return this;
    }

    public CriteriaQuery<T> except(CriteriaQuery<?> other) {
        this.unions.add(new Except(other));
        return this;
    }

    /**
     * Generates the select clause of the SQL query. Column names are aliased with
     * their corresponding Java field names.
     *
     * @return The select clause of the SQL query.
     */
    private String select() {
        String select = selections
                .stream()
                .sorted()
                .map(this::toSql)
                .collect(Collectors.joining(","));
        return defaultIfEmpty(select, " * ");

    }

    private String update() {
        return this.selections
                .stream()
                .sorted()
                .map(selectable -> {
                    if (selectable instanceof Path<?> path) {
                        return path;
                    }
                    throw new RuntimeException("not a path");
                })
                .map(path -> EntityRegistry.paths.get(path) + " = :" + path.getAttribute())
                .collect(Collectors.joining(", "));

    }

    private String toSql(Selectable attr) {
        String str = attr.toSql();
        if (isNotBlank(attr.getAlias())) {
            return str + " as " + attr.getAlias();
        }
        return str;
    }

    /**
     * Generates the where clause of the SQL query.
     *
     * @return The where clause of the SQL query.
     */
    private String where() {
        String sql = where.toSql();
        if (sql.isEmpty()) {
            return "";
        }
        return " where (" + sql + ")";
    }

    /**
     * Generates the column names for an insert query.
     *
     * @return The comma-separated list of column names.
     */
    private String insert() {
        return selections
                .stream()
                .map(selectable -> {
                    if (selectable instanceof Path<?> path) {
                        return path;
                    }
                    throw new RuntimeException("not a path");
                })
                .map(EntityRegistry::resolvePath)
                .collect(Collectors.joining(","));
    }

    /**
     * Generates the values placeholder for an insert query.
     *
     * @return The comma-separated list of values placeholders.
     */
    private String values() {
        return selections
                .stream()
                .map(selectable -> {
                    if (selectable instanceof Path<?> path) {
                        return path;
                    }
                    throw new RuntimeException("not a path");
                })
                .map(path -> new StringBuilder(":").append(path.getAttribute()))
                .collect(Collectors.joining(","));
    }

    /**
     * Returns the alias of the given root entity. If no alias is explicitly set,
     * the source table name is used as the alias.
     *
     * @param root The root entity.
     * @return The alias of the root entity.
     */
    private String alias(Root<?> root) {
        if (isNotBlank(root.getAlias())) {
            return root.getAlias();
        }
        return sourceTable(root);
    }

    /**
     * Returns the source table name for the given root entity. This method takes
     * into account any prefixes or custom table name mappings applied to the query.
     *
     * @param root The root entity.
     * @return The source table name.
     */
    private String sourceTable(Root<?> root) {
        String rootTable = EntityRegistry.roots.get(root);
        return root.schema() + rootTable;
    }

    /**
     * Builds a select query based on the criteria defined in this query builder.
     * The query includes the select clause, from clause, joins, where clause,
     * group by clause, and order by clause.
     *
     * @return The complete select query.
     */
    public String buildSelectQuery() {
        checkSelection();
        if (unions.isEmpty() || orderBy.isEmpty() && pagination.isVoid()) {
            return buildSimpleSelectQuery();
        }
        return buildNestedSelectQuery();
    }

    public String buildNamedUpdateQuery() {
        checkSelection();
        return new StringBuilder().append("update ")
                .append(froms())
                .append(" set ")
                .append(update())
                .toString();
    }

    protected void checkSelection() {
        if (selections.isEmpty()) {
            froms.forEach(this::select);
        }
    }

    private String buildSimpleSelectQuery() {
        return new StringBuilder().append("select ")
                .append(select())
                .append(" from ")
                .append(froms())
                .append(" ")
                .append(joins())
                .append(" ")
                .append(where())
                .append(" ")
                .append(groupBy())
                .append(" ")
                .append(having())
                .append(" ")
                .append(orderBy())
                .append(" ")
                .append(unions())
                .append(" ")
                .append(limitOffset())
                .toString()
                .trim()
                .replaceAll("  +", " ");
    }

    private String buildNestedSelectQuery() {
        Pagination pagination1 = Pagination.from(this.pagination);
        Subquery subquery = new Subquery(this, criteriaBuilder.getSqlDialect());
        subquery.setAlias("nested_query");
        var nq = new CriteriaQuery<>(this.resultType, criteriaBuilder);
        nq.from(subquery);
        this.orderBy.forEach((order) -> {
            Selectable p = new Path<>("nested_query", order.getColumn().getAlias());
            nq.orderBy(p, order.getDirection());
        });
        nq.pagination.apply(pagination1);
        subquery.cr().orderBy.clear();
        subquery.cr().pagination.clear();
        //
        return nq.buildSelectQuery();
    }

    private String unions() {
        StringBuilder sb = new StringBuilder();
        for (SetOperation union : unions) {
            sb.append(" ").append(union.toSql());
        }
        return sb.toString();
    }

    private String having() {
        String toString = this.having.toSql();
        if (toString.isEmpty()) {
            return "";
        }
        return " having " + toString;
    }

    /**
     * Builds a count query based on the criteria defined in this query builder.
     * The query counts all rows matching the criteria, excluding the order by clause.
     *
     * @return The count query.
     */
    public String buildCountQuery() {
        return new StringBuilder().append("select count(*)")
                .append(" from ")
                .append(froms())
                .append(" ")
                .append(" ")
                .append(joins())
                .append(" ")
                .append(where())
                .append(" ")
                .append(groupBy())
                .append(" ")
                .toString()
                .trim()
                .replaceAll("  +", " ");
    }

    /**
     * Generates the joins clause of the SQL query.
     *
     * @return The joins clause of the SQL query.
     */
    private String joins() {
        return this.joins.stream()
                .map(Join::toSql)
                .collect(Collectors.joining(" "));
    }

    /**
     * Builds a delete query based on the criteria defined in this query builder.
     * The query deletes all rows matching the where clause.
     *
     * @return The delete query.
     */
    public String buildDeleteQuery() {
        return new StringBuilder().append("delete from ")
                .append(froms())
                .append(" ")
                .append(where())
                .append(" ")
                .toString()
                .trim()
                .replaceAll("  +", " ");
    }

    /**
     * Builds an insert query with named parameters. The query inserts data into
     * the specified columns. Use {@link #select()} to limit the scope of attributes
     * to be inserted.
     *
     * @return The parameterized insert query.
     */
    public String buildInsertQuery() {
        return new StringBuilder().append("insert into ")
                .append(into())
                .append(" (")
                .append(insert())
                .append(")")
                .append(" values ")
                .append("(")
                .append(values())
                .append(")")
                .toString()
                .trim()
                .replaceAll("  +", " ");
    }

    /**
     * Generates the order by clause of the SQL query.
     *
     * @return The order by clause of the SQL query.
     */
    private String orderBy() {
        String orderBy = this.orderBy
                .stream()
                .map(order -> new StringBuilder(fullResolve(order.getColumn()))
                        .append(" ")
                        .append(order.getDirection())
                )
                .map(StringBuilder::toString)
                .collect(Collectors.joining(","));
        return orderBy.isEmpty() ? "" : " order by " + orderBy;
    }

    private String limitOffset() {
        return pagination.render();
    }

    /**
     * Generates the group by clause of the SQL query.
     *
     * @return The group by clause of the SQL query.
     */
    private String groupBy() {
        String groupByClause = this.groupBy
                .stream()
                .map(EntityRegistry::fullResolve)
                .collect(Collectors.joining(","));
        return groupByClause.isEmpty() ? "" : " group by " + groupByClause;
    }

    /**
     * Returns a list of fields selected in this query. If no specific selection
     * is defined, all selectable fields of the root entity are returned.
     *
     * @return The list of selected fields.
     */
    public List<FieldMetaData> getFields() {
        return this.selections
                .stream()
                .map(select -> {
                    FieldMetaData field = new FieldMetaData();
                    field.setLabel(select.getAlias());
                    field.setColumn(select.getColumn());
                    try {
                        Field declaredField = this.getResultType().getDeclaredField(select.getAlias());
                        field.setJavaType(declaredField.getType());
                    } catch (NoSuchFieldException e) {
                        throw new RuntimeException(e);
                    }
                    return field;
                })
                .sorted(Comparator.comparing(FieldMetaData::getLabel))
                .collect(Collectors.toList());
    }

    public LinkedHashSet<Selectable> getSelect() {
        return selections;
    }
}
package com.ainouss.jdatatools.query.core;

import com.ainouss.jdatatools.query.dialect.SqlDialect;

public class Cte<T> extends CriteriaQuery<T> implements Source {

    private CriteriaQuery<?> cr;
    private final String name;
    private final SqlDialect sqlDialect;

    public Cte(String name, SqlDialect sqlDialect) {
        super(); // No Class<T> or CriteriaBuilder needed for CTE constructor
        this.name = name;
        this.sqlDialect = sqlDialect;
    }

    public Cte(String name) { // For CriteriaBuilder default constructor
        this(name, null);
    }


    public Cte<T> as(CriteriaQuery<?> cr) {
        this.cr = cr;
        return this;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public String toSql() {
        return "with " + name + " as (" + cr.buildSelectQuery() + ")";
    }

    @Override
    public String buildSelectQuery() {
        String select = super.buildSelectQuery();
        return toSql() + " " + select;
    }

    @Override
    public Selectable get(String attr) {
        cr.checkSelection();
        return new Path<>(name, attr);
    }

    @Override
    public String getAlias() {
        return this.name;
    }

    @Override
    public void setAlias(String alias) {
        throw new UnsupportedOperationException("Alias is not supported for CTE");
    }
}
package com.ainouss.jdatatools.query.core;

/**
 * Identity expression, renders an empty SQL
 */
public class EmptyExpression implements Expression {

    public EmptyExpression() {
    }

    @Override
    public String toSql() {
        return "";
    }
}

package com.ainouss.jdatatools.query.core;

public interface Expression extends Fragment {

    //String toSql(SqlGenerator<T> sqlGenerator);

}

package com.ainouss.jdatatools.query.core;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class FieldMetaData {

    private String label;
    private String column;
    private Class<?> javaType;

}

package com.ainouss.jdatatools.query.core;

public interface Fragment {

    String toSql();

}

package com.ainouss.jdatatools.query.core;

import com.ainouss.jdatatools.query.util.DataUtils;

public class LiteralValue extends Alias implements Selectable {

    private final Object value;

    public LiteralValue(Object value) {
        this.value = value;
    }

    @Override
    public String toSql() {
        if (value == null) {
            return null;
        }
        if (value instanceof String strValue) {
            return "'" + DataUtils.escapeSql(strValue) + "'";
        } else if (value instanceof Number) {
            return value.toString();
        } else if (value instanceof Fragment fr) {
            return fr.toSql();
        }
        return value.toString();
    }
}

package com.ainouss.jdatatools.query.core;

import com.ainouss.jdatatools.query.dialect.SqlDialect;
import lombok.Data;

@Data
public class Pagination {

    private Integer limit;
    private Integer offset;
    private final SqlDialect sqlDialect;

    public Pagination(SqlDialect sqlDialect) {
        this.sqlDialect = sqlDialect;
    }

    public Pagination() {
        this(null); // For CTE - default constructor
    }

    public Pagination(Integer limit, Integer offset, SqlDialect sqlDialect) {
        this.limit = limit;
        this.offset = offset;
        this.sqlDialect = sqlDialect;
    }


    public static Pagination from(Pagination pagination) {
        return new Pagination(pagination.getLimit(), pagination.getOffset(), pagination.getSqlDialect());
    }

    public void apply(Pagination pagination) {
        this.limit = pagination.getLimit();
        this.offset = pagination.getOffset();
    }

    public boolean isVoid() {
        return limit == null && offset == null;
    }

    public String render() {
        if (this.isVoid() || sqlDialect == null) {
            return "";
        }
        return sqlDialect.getLimitOffsetSql(limit, offset);
    }

    public void clear() {
        this.limit = null;
        this.offset = null;
    }
}
package com.ainouss.jdatatools.query.core;

import com.ainouss.jdatatools.query.order.Order;
import com.ainouss.jdatatools.query.order.OrderDirection;
import com.ainouss.jdatatools.query.registery.EntityRegistry;
import lombok.Getter;

import java.util.Objects;

/**
 * Description of a path to an attribute or join or selection
 *
 * @param <T> Type
 */
@Getter
public class Path<T> extends Alias implements Selectable {

    protected final Root<T> head;

    protected final String attribute;


    public Path(Root<T> head, String attribute) {
        this.head = head;
        this.attribute = attribute;
        this.alias = attribute;
    }

    public Path(String name, String attr) {
        this.head = new Root<>(name);
        this.attribute = attr;
        this.alias = attr;
    }

    public final Path<?> get(String id) {
        return new Path<>(this.head, id);
    }

    public final Order asc() {
        return new Order(this, OrderDirection.ASC);
    }
    public final Order desc() {
        return new Order(this, OrderDirection.ASC);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Path<?> path = (Path<?>) o;
        return Objects.equals(head, path.head) && Objects.equals(attribute, path.attribute);
    }

    @Override
    public int hashCode() {
        return Objects.hash(head, attribute);
    }


    @Override
    public String toSql() {
        return EntityRegistry.fullResolve(this);
    }
}

package com.ainouss.jdatatools.query.core;

import com.ainouss.jdatatools.query.join.Joinable;
import com.ainouss.jdatatools.query.registery.EntityRegistry;
import lombok.Getter;

import java.util.Objects;

import static org.apache.commons.lang3.StringUtils.isBlank;

/**
 * Root object, equivalent to a table in RDBMS
 * Alias is a SQL alias for table name
 * Every root should be annotated with {@link jakarta.persistence.Table} annotation
 *
 * @param <T> Java class
 */
@Getter
public class Root<T> extends Alias implements Selectable, Source, Joinable<T> {

    private final Class<T> javaType;

    private final String table;

    private String schema;

    public Root(Class<T> from) {
        this.javaType = from;
        this.alias = EntityRegistry.roots.get(this);
        this.table = EntityRegistry.roots.get(this);
    }

    public Root(String name) {
        this.javaType = null;
        this.alias = name;
        this.table = name;
    }

    /**
     * A path that starts from this root
     *
     * @param attribute java field name
     * @return path
     */
    public Path<T> get(String attribute) {
        return new Path<>(this, attribute);
    }


    /**
     * SQL table alias
     *
     * @param alias alias
     * @return alias
     */
    public Root<T> as(String alias) {
        this.alias = alias;
        return this;
    }

    public Root<T> schema(String schema) {
        this.schema = schema;
        return this;
    }

    public String schema() {
        if (isBlank(schema)) {
            return "";
        }
        return schema + ".";
    }

    @Override
    public String toSql() {
        return alias;
    }

    @Override
    public String getName() {
        return new StringBuilder(schema())
                .append(EntityRegistry.roots.get(this))
                .toString();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Root<?> root = (Root<?>) o;
        return Objects.equals(javaType, root.javaType);
    }

    @Override
    public int hashCode() {
        return Objects.hash(javaType);
    }

    @Override
    public Source getSelf() {
        return this;
    }

}

package com.ainouss.jdatatools.query.core;

public class ScalarQuery<T> extends Alias implements Selectable {

    private final CriteriaQuery<T> criteria;

    public ScalarQuery(CriteriaQuery<T> criteria) {
        this.criteria = criteria;
        this.alias = criteria.getSelect().stream()
                .findAny()
                .map(Selectable::getAlias)
                .orElse("");
    }


    @Override
    public String toSql() {
        return " (" + criteria.buildSelectQuery() + ")";
    }
}

package com.ainouss.jdatatools.query.core;

import com.ainouss.jdatatools.query.util.DataUtils;

public interface Selectable extends Expression, WithAlias, Comparable<Selectable> {

    default String getColumn() {
        String sql = toSql();
        if (DataUtils.isBlank(sql)) {
            return "";
        }
        if (sql.contains(".")) {
            return sql.substring(sql.lastIndexOf(".") + 1);
        }
        return sql;
    }

    default Selectable as(String alias) {
        setAlias(alias);
        return this;
    }

    @Override
    default int compareTo(Selectable o) {
        String alias = getAlias();
        if (alias == null) {
            return 0;
        }
        return alias.compareTo(o.getAlias());
    }
}

package com.ainouss.jdatatools.query.core;

/**
 * Identity expression, renders an empty SQL
 */
public class SelectableExpression implements Expression {

    private final Selectable selectable;

    public SelectableExpression(Selectable expression) {
        this.selectable = expression;
    }

    @Override
    public String toSql() {
        return selectable.toSql();
    }
}

package com.ainouss.jdatatools.query.core;

import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Where expression, entry point to where conditions
 */
public class SimpleExpression implements Expression {

    private Expression expression;
    private final SqlDialect sqlDialect;

    public SimpleExpression(SqlDialect sqlDialect) {
        this.sqlDialect = sqlDialect;
    }

    public SimpleExpression() {
        this(null); // For CTE - default constructor
    }


    public void with(Expression expression) {
        this.expression = expression;
    }

    public String toSql() {
        if (expression == null) {
            return "";
        }
        return expression.toSql();
    }
}
package com.ainouss.jdatatools.query.core;

public interface Source extends Fragment, WithAlias {

    Selectable get(String attr);

    default String getName() {
        return toSql();
    }

    String getAlias();

    void setAlias(String alias);

}

package com.ainouss.jdatatools.query.core;

import com.ainouss.jdatatools.query.dialect.SqlDialect;

public class Subquery extends Alias implements Source {

    private final CriteriaQuery<?> cr;
    private final SqlDialect sqlDialect;

    public Subquery(CriteriaQuery<?> criteria, SqlDialect sqlDialect) {
        this.cr = criteria;
        this.sqlDialect = sqlDialect;
    }

    public CriteriaQuery<?> cr() {
        return cr;
    }

    @Override
    public String toSql() {
        return " (" + cr.buildSelectQuery() + ") ";
    }

    @Override
    public Selectable get(String attr) {
        return new Path<>(alias, attr);
    }


    public SqlDialect getSqlDialect() {
        return sqlDialect;
    }
}
package com.ainouss.jdatatools.query.core;

public interface WithAlias {

    void setAlias(String alias);

    String getAlias();

}

package com.ainouss.jdatatools.query.dialect;

public abstract class AbstractSqlDialect implements SqlDialect {

    @Override
    public String getBooleanValue(boolean value) {
        return value ? "true" : "false"; // Default to standard SQL boolean literals
    }

    @Override
    public String getStringConcatenation(String... parts) {
        return "concat(" + String.join(", ", parts) + ")"; // Default to CONCAT function
    }

    @Override
    public String escapeIdentifier(String identifier) {
        return identifier;// Default to double quotes (standard SQL)
    }

    @Override
    public String getLimitOffsetSql(Integer limit, Integer offset) {
        if (limit != null && offset != null) {
            return "limit " + limit + " offset " + offset; // Default LIMIT OFFSET
        } else if (limit != null) {
            return "limit " + limit;
        } else if (offset != null) {
            return "offset " + offset; // Some databases might not support OFFSET without LIMIT
        }
        return "";
    }

    @Override
    public String getDistinctKeyword() {
        return "distinct"; // Default DISTINCT keyword
    }
}
package com.ainouss.jdatatools.query.dialect;

public class MySqlDialect extends AbstractSqlDialect {

    @Override
    public String getStringConcatenation(String... parts) {
        return "CONCAT(" + String.join(", ", parts) + ")"; // MySQL uses CONCAT
    }

    @Override
    public String escapeIdentifier(String identifier) {
        return "`" + identifier + "`"; // MySQL uses backticks for identifiers
    }

    @Override
    public String getLimitOffsetSql(Integer limit, Integer offset) {
        if (limit != null && offset != null) {
            return "LIMIT " + limit + " OFFSET " + offset; // MySQL standard LIMIT OFFSET
        } else if (limit != null) {
            return "LIMIT " + limit;
        } else if (offset != null) {
            return "OFFSET " + offset; // MySQL supports OFFSET without LIMIT (though not standard SQL)
        }
        return "";
    }
}
package com.ainouss.jdatatools.query.dialect;

public class PostgreSqlDialect extends AbstractSqlDialect {

    @Override
    public String getStringConcatenation(String... parts) {
        return String.join(" || ", parts); // PostgreSQL uses || for concatenation
    }

    @Override
    public String escapeIdentifier(String identifier) {
        return "\"" + identifier + "\""; // PostgreSQL uses double quotes (standard SQL)
    }

    @Override
    public String getLimitOffsetSql(Integer limit, Integer offset) {
        return super.getLimitOffsetSql(limit, offset); // Uses default LIMIT OFFSET, which PostgreSQL supports
    }
}
package com.ainouss.jdatatools.query.dialect;

public interface SqlDialect {

    /**
     * Gets the SQL representation for limiting query results with limit and offset.
     *
     * @param limit  The maximum number of rows to return.
     * @param offset The starting offset of the first row to return.
     * @return SQL fragment for LIMIT and OFFSET clauses.
     */
    String getLimitOffsetSql(Integer limit, Integer offset);

    /**
     * Gets the SQL representation for a boolean value.
     *
     * @param value The boolean value.
     * @return SQL string for boolean (e.g., 'TRUE', 'FALSE', '1', '0').
     */
    String getBooleanValue(boolean value);

    /**
     * Gets the SQL representation for string concatenation.
     *
     * @param parts Strings to concatenate.
     * @return SQL string for concatenation.
     */
    String getStringConcatenation(String... parts);

    /**
     * Escapes an identifier (table name, column name) for the specific dialect.
     *
     * @param identifier The identifier to escape.
     * @return Escaped identifier.
     */
    String escapeIdentifier(String identifier);

    /**
     * Gets the SQL keyword for 'DISTINCT' keyword, some dialects may require specific syntax.
     * @return SQL keyword for DISTINCT.
     */
    String getDistinctKeyword();
}
package com.ainouss.jdatatools.query.dialect;

public class SqlDialectFactory {

    public static SqlDialect getDialect(String dialectName) {
        if ("mysql".equalsIgnoreCase(dialectName)) {
            return new MySqlDialect();
        } else if ("postgresql".equalsIgnoreCase(dialectName)) {
            return new PostgreSqlDialect();
        } else if ("sqlserver".equalsIgnoreCase(dialectName)) {
            return new SqlServerDialect();
        }
        // Add more dialect options here
        return new StandardDialect(); // Default to standard SQL if dialect not recognized
    }
}
package com.ainouss.jdatatools.query.dialect;

public class SqlServerDialect extends AbstractSqlDialect {

    @Override
    public String getStringConcatenation(String... parts) {
        return String.join(" + ", parts); // SQL Server uses + for concatenation (in many contexts)
    }

    @Override
    public String escapeIdentifier(String identifier) {
        return "[" + identifier + "]"; // SQL Server uses square brackets
    }

    @Override
    public String getLimitOffsetSql(Integer limit, Integer offset) {
        if (limit != null && offset != null) {
            return "OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY"; // SQL Server specific syntax
        } else if (limit != null) {
            return "TOP " + limit; // TOP for just limit in SQL Server
        } else if (offset != null) {
            return "OFFSET " + offset + " ROWS"; // OFFSET without LIMIT in SQL Server
        }
        return "";
    }
}
package com.ainouss.jdatatools.query.dialect;

public class StandardDialect extends AbstractSqlDialect{
}

package com.ainouss.jdatatools.query.function;

import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.order.Order;

public interface Aggregable extends Selectable {

    AggregateFunction partitionBy(Selectable... partitions);

    AggregateFunction orderBy(Order... orders);

    Aggregable over();

}

package com.ainouss.jdatatools.query.function;

import com.ainouss.jdatatools.query.core.Alias;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;
import com.ainouss.jdatatools.query.order.Order;

import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.stream.Collectors;

public abstract class AggregateFunction extends Alias implements Aggregable {

    protected final Selectable selectable;
    private final LinkedHashSet<Selectable> partitionBy = new LinkedHashSet<>();
    protected final LinkedHashSet<Order> orderBy = new LinkedHashSet<>();
    private final SqlDialect sqlDialect;

    protected AggregateFunction(SqlDialect sqlDialect) {
        this.selectable = null;
        this.sqlDialect = sqlDialect;
    }

    public AggregateFunction(Selectable selectable, SqlDialect sqlDialect) {
        this.selectable = selectable;
        this.sqlDialect = sqlDialect;
    }

    public abstract String sql();

    @Override
    public AggregateFunction partitionBy(Selectable... partitions) {
        partitionBy.addAll(Arrays.asList(partitions));
        return this;
    }

    @Override
    public AggregateFunction orderBy(Order... orders) {
        orderBy.addAll(Arrays.asList(orders));
        return this;
    }

    @Override
    public Aggregable over() {
        return this;
    }

    private String overSql() {
        if (partitionBy.isEmpty() && orderBy.isEmpty()) {
            return "";
        }
        return new StringBuilder(" over (")
                .append(partitions())
                .append(orders())
                .append(")")
                .toString();
    }

    private String orders() {
        if(orderBy.isEmpty()){
            return "";
        }
        String parts = orderBy.stream().map(Order::toSql).collect(Collectors.joining(","));
        return new StringBuilder(" order by ")
                .append(parts)
                .toString();
    }

    private String partitions() {
        if (partitionBy.isEmpty()) {
            return "";
        }
        return new StringBuilder("partition by ")
                .append(partitionBy.stream().map(Selectable::toSql).collect(Collectors.joining(",")))
                .toString();
    }

    @Override
    public String toSql() {
        return sql() + overSql();
    }



}
package com.ainouss.jdatatools.query.function;

import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Avg aggregate function
 */
public class Avg extends AggregateFunction {

    public Avg(Selectable selectable, SqlDialect sqlDialect) {
        super(selectable, sqlDialect);
    }

    @Override
    public String sql() {
        return "avg(" + selectable.toSql() + ")";
    }

}
package com.ainouss.jdatatools.query.function;

import com.ainouss.jdatatools.query.core.Root;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Avg aggregate function
 */
public class Count extends AggregateFunction {

    private final SqlDialect sqlDialect;

    public Count(Selectable selectable, SqlDialect sqlDialect) {
        super(selectable, sqlDialect);
        this.sqlDialect = sqlDialect;
    }

    public Count(SqlDialect sqlDialect) {
        super(sqlDialect);
        this.sqlDialect = sqlDialect;
    }


    @Override
    public String sql() {
        if (selectable == null || selectable instanceof Root<?>) {
            return "count(*)";
        }
        return "count(" + selectable.toSql() + ")";
    }


}
package com.ainouss.jdatatools.query.function;

import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Avg aggregate function
 */
public class Distinct extends AggregateFunction {

    private final SqlDialect sqlDialect;

    public Distinct(Selectable selectable, SqlDialect sqlDialect) {
        super(selectable, sqlDialect);
        this.sqlDialect = sqlDialect;
    }

    @Override
    public String sql() {
        return sqlDialect.getDistinctKeyword() + " " + selectable.toSql();
    }

}
package com.ainouss.jdatatools.query.function;

import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Avg aggregate function
 */
public class Max extends AggregateFunction {

    private final SqlDialect sqlDialect;

    public Max(Selectable selectable, SqlDialect sqlDialect) {
        super(selectable, sqlDialect);
        this.sqlDialect = sqlDialect;// Dialect Integration
    }

    @Override
    public String sql() {
        return "max(" + selectable.toSql() + ")";
    }

}
package com.ainouss.jdatatools.query.function;

import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Avg aggregate function
 */
public class Min extends AggregateFunction {

    private final SqlDialect sqlDialect;

    public Min(Selectable selectable, SqlDialect sqlDialect) {
        super(selectable, sqlDialect);
        this.sqlDialect = sqlDialect;
    }

    @Override
    public String sql() {
        return "min(" + selectable.toSql() + ")";
    }

}
package com.ainouss.jdatatools.query.function;

import com.ainouss.jdatatools.query.dialect.SqlDialect;

public class Rank extends AggregateFunction {

    private final SqlDialect sqlDialect;
    public Rank(SqlDialect sqlDialect) {
        super(sqlDialect);
        this.sqlDialect = sqlDialect;
    }

    public Rank() { // For CTE - default constructor
        this(null);
    }


    @Override
    public String sql() {
        return "rank()";
    }
}
package com.ainouss.jdatatools.query.function;

import com.ainouss.jdatatools.query.dialect.SqlDialect;

public class RowNumber extends AggregateFunction {

    private final SqlDialect sqlDialect;

    public RowNumber(SqlDialect sqlDialect) {
        super(sqlDialect);
        this.sqlDialect = sqlDialect;
    }

    public RowNumber() { // For CTE - default constructor
        this(null);
    }


    @Override
    public String sql() {
        return "row_number()";
    }
}
package com.ainouss.jdatatools.query.function;

import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Avg aggregate function
 */
public class Sum extends AggregateFunction {

    private final SqlDialect sqlDialect;

    public Sum(Selectable selectable, SqlDialect sqlDialect) {
        super(selectable, sqlDialect);
        this.sqlDialect = sqlDialect;// Dialect Integration
    }

    @Override
    public String sql() {
        return "sum(" + selectable.toSql() + ")";
    }

}
package com.ainouss.jdatatools.query.join;

import com.ainouss.jdatatools.query.core.*;
import lombok.Getter;

/**
 * Represents a join between two sources.
 *
 * @param <X> the type of the source.
 * @param <Y> the type of the target.
 */
@Getter
public class Join<X, Y> extends Alias implements Source, Joinable<Y> {

    private final Source target;
    private final Source source;
    private final JoinType joinType;
    private Expression expression;
    private CriteriaQuery<?> subquery;

    /**
     * Creates a join.
     *
     * @param source   the join source.
     * @param target   the join target.
     * @param joinType the type of the join.
     */
    public Join(Source source, Source target, JoinType joinType) {
        this.source = source;
        this.target = target;
        this.joinType = joinType;
    }

    public Join<X, Y> on(Expression on) {
        this.expression = on;
        return this;
    }

    public Join<X, Y> on(CriteriaQuery<?> subquery) {
        this.subquery = subquery;
        return this;
    }

    /**
     * Generates the SQL for this join.
     */
    public String toSql() {
        return new StringBuilder(source.getName())
                .append(" ")
                .append(source.getAlias())
                .append(" ")
                .append(this.getJoinType().name().toLowerCase())
                .append(" join ")
                .append(target.getName())
                .append(" ")
                .append(target.getAlias())
                .append(getStatement())
                .toString();
    }

    private String getStatement() {
        if (this.expression != null) {
            return " on " + expression.toSql();
        }
        if (this.subquery != null) {
            return " on (" + subquery.buildSelectQuery() + ")";
        }
        return "";
    }

    @Override
    public Selectable get(String attr) {
        return new Path<>(alias, attr);
    }

    @Override
    public Source getSelf() {
        return this;
    }
}

package com.ainouss.jdatatools.query.join;

import com.ainouss.jdatatools.query.core.Fragment;
import com.ainouss.jdatatools.query.core.Source;

public interface Joinable<T> extends Fragment {

    Source getSelf();

    /**
     * Left join expression
     *
     * @param root target
     * @param <U>  target classs
     * @return join expression
     */
    default <U> JoinExpression<T, U> leftJoin(Source root) {
        Join<T, U> join = new Join<>(getSelf(), root, JoinType.LEFT);
        return new JoinExpression<>(join);
    }

    /**
     * Right join expression
     *
     * @param root target
     * @param <U>  target classs
     * @return join expression
     */
    default <U> JoinExpression<T, U> rightJoin(Source root) {
        Join<T, U> join = new Join<>(getSelf(), root, JoinType.RIGHT);
        return new JoinExpression<>(join);
    }

    /**
     * Inner join expression
     *
     * @param root target
     * @param <U>  target classs
     * @return join expression
     */
    default <U> JoinExpression<T, U> innerJoin(Source root) {
        Join<T, U> join = new Join<>(getSelf(), root, JoinType.INNER);
        return new JoinExpression<>(join);
    }

    /**
     * Full join expression
     *
     * @param root target
     * @param <U>  target classs
     * @return join expression
     */

    default <U> JoinExpression<T, U> fullJoin(Source root) {
        Join<T, U> join = new Join<>(getSelf(), root, JoinType.FULL);
        return new JoinExpression<>(join);
    }

    /**
     * Cross join expression, does not have on clause, thus returns a join directly
     *
     * @param root target
     * @param <U>  target classs
     * @return join expression
     */
    default <U> Join<T, U> join(Source root) {
        return new Join<>(getSelf(), root, JoinType.CROSS);
    }
}

package com.ainouss.jdatatools.query.join;

import com.ainouss.jdatatools.query.core.*;

/**
 * Join expression, intermediate operation that returns a join through on function
 * On clause is  mandatory all joins except cross join
 *
 * @param <T> source
 * @param <U> target
 */
public class JoinExpression<T, U> extends Alias {

    private final Join<T, U> join;


    public JoinExpression(Join<T, U> join) {
        this.join = join;
    }

    /**
     * On condition, not applicable to a cartesian product
     */
    public Join<T, U> on(Expression expression) {
        if (join.getJoinType() == JoinType.CROSS) {
            return join;
        }
        return join.on(expression);
    }

    public Join<T, U> on(CriteriaQuery<?> subquery) {
        return join.on(subquery);
    }


}

package com.ainouss.jdatatools.query.join;

/**
 * Join Types
 */
public enum JoinType {
    LEFT,
    RIGHT,
    INNER,
    FULL,
    CROSS
}

package com.ainouss.jdatatools.query.logical;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * An expression is defined on a path, has a value and can have a logical combination of embedded expressions using
 * (and, or, not)
 * An expression can have an SQL string
 */
public abstract class AbstractExpression implements Expression {

    protected List<Expression> and = new ArrayList<>();
    protected List<Expression> or = new ArrayList<>();
    private final SqlDialect sqlDialect;

    public AbstractExpression(SqlDialect sqlDialect) {
        this.sqlDialect = sqlDialect;
    }
    public AbstractExpression() { // For CTE - default constructor
        this(null);
    }


    /**
     * Adds to its ands
     *
     * @param expressions other expressions
     * @return this
     */
    public AbstractExpression and(Expression... expressions) {
        and.addAll(Arrays.asList(expressions));
        return this;
    }


    /**
     * Adds to its ors
     *
     * @param expressions other expressions
     * @return this
     */
    public AbstractExpression or(Expression... expressions) {
        or.addAll(Arrays.asList(expressions));
        return this;
    }

    /**
     * SQL that would be appended while rendering
     *
     * @return sql fragment
     */

    public String toSql() {

        StringBuilder sqlBuilder = new StringBuilder();
        boolean hasContent = false;

        if (!and.isEmpty()) {
            sqlBuilder.append("(");
            boolean first = true;
            for (Expression expression : and) {
                if (!first) {
                    sqlBuilder.append(" and ");
                }
                sqlBuilder.append(expression.toSql());
                first = false;
            }
            sqlBuilder.append(")");
            hasContent = true;
        }

        if (!or.isEmpty()) {
            if (hasContent) {
                sqlBuilder.append(" or ");
            }
            sqlBuilder.append("(");
            boolean first = true;
            for (Expression expression : or) {
                if (!first) {
                    sqlBuilder.append(" or ");
                }
                sqlBuilder.append(expression.toSql());
                first = false;
            }
            sqlBuilder.append(")");
        }
        return sqlBuilder.toString();
    }
}
package com.ainouss.jdatatools.query.logical;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Represents the logical AND operator in a query.
 * <p>
 * This class is used to combine multiple expressions into a single
 * conditional statement where all expressions must evaluate to true
 * for the overall condition to be true.
 * <p>
 * Example usage:
 * <pre>
 *  CriteriaBuilder cb = new CriteriaBuilder();
 *  CriteriaQuery<MyEntity> query = cb.createQuery(MyEntity.class);
 *  Root<MyEntity> root = query.from();
 *  query.where(
 *      cb.and(
 *          cb.eq(root.get("name"), "John Doe"),
 *          cb.gt(root.get("salary"), 30)
 *      )
 *  );
 * </pre>
 * This would generate the following SQL WHERE clause:
 * <pre>
 *  WHERE name = 'John Doe' AND salary > 30
 * </pre>
 */
public class And extends AbstractExpression {

    /**
     * Constructs a new {@code And} operator with the given expression.
     *
     * @param expression The expression to add to the AND condition.
     * @param sqlDialect The SQL dialect to use for rendering.
     */
    public And(Expression expression, SqlDialect sqlDialect) {
        super(sqlDialect);
        this.and.add(expression);
    }
}
package com.ainouss.jdatatools.query.logical;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Represents the logical NOT operator in a query.
 * <p>
 * This class is used to negate the result of an expression.
 * <p>
 * Example usage:
 * <pre>
 *  CriteriaBuilder cb = new CriteriaBuilder();
 *  CriteriaQuery<MyEntity> query = cb.createQuery(MyEntity.class);
 *  Root<MyEntity> root = query.from();
 *  query.where(
 *      cb.not(
 *          cb.eq(root.get("active"), true)
 *      )
 *  );
 * </pre>
 * This would generate the following SQL WHERE clause:
 * <pre>
 *  WHERE NOT active = true
 * </pre>
 */
public class Not implements Expression {

    private final Expression expression;
    private final SqlDialect sqlDialect;

    /**
     * Constructs a new {@code Not} operator with the given expression.
     *
     * @param expression The expression to be negated.
     * @param sqlDialect The SQL dialect to use for rendering.
     */
    public Not(Expression expression, SqlDialect sqlDialect) {
        this.expression = expression;
        this.sqlDialect = sqlDialect;
    }

    @Override
    public String toSql() {
        String sql = expression.toSql();
        if (sql == null) {
            return "not null";
        }
        return "not (" + sql + ")";
    }
}
package com.ainouss.jdatatools.query.logical;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Represents the logical OR operator in a query.
 * <p>
 * This class is used to combine multiple expressions into a single
 * conditional statement where at least one expression must evaluate
 * to true for the overall condition to be true.
 * <p>
 * Example usage:
 * <pre>
 *  CriteriaBuilder cb = new CriteriaBuilder();
 *  CriteriaQuery<MyEntity> query = cb.createQuery(MyEntity.class);
 *  Root<MyEntity> root = query.from();
 *  query.where(
 *      cb.or(
 *          cb.eq(root.get("city"), "New York"),
 *          cb.eq(root.get("city"), "Los Angeles")
 *      )
 *  );
 * </pre>
 * This would generate the following SQL WHERE clause:
 * <pre>
 *  WHERE city = 'New York' OR city = 'Los Angeles'
 * </pre>
 */
public class Or extends AbstractExpression {

    /**
     * Constructs a new {@code Or} operator with the given expression.
     *
     * @param expression The expression to add to the OR condition.
     * @param sqlDialect The SQL dialect to use for rendering.
     */
    public Or(Expression expression, SqlDialect sqlDialect) {
        super(sqlDialect);
        this.or.add(expression);
    }

}
package com.ainouss.jdatatools.query.operator;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Represents the BETWEEN operator in a query.
 * <p>
 * This class is used to check if a value is within a specified range.
 * It can be used with numbers and paths.
 * <p>
 * Example usage:
 * <pre>
 *  CriteriaBuilder cb = new CriteriaBuilder();
 *  CriteriaQuery<MyEntity> query = cb.createQuery(MyEntity.class);
 *  Root<MyEntity> root = query.from();
 *  query.where(cb.bt(root.get("salary"), 20, 40));
 * </pre>
 * This would generate the following SQL WHERE clause:
 * <pre>
 *  WHERE salary BETWEEN 20 AND 40
 * </pre>
 */
public class Bt implements Expression {

    private final Selectable attribute;
    private final Selectable left;
    private final Selectable right;
    private final SqlDialect sqlDialect;

    /**
     * Constructs a new {@code Bt} operator with the given path and range values.
     *
     * @param selectable The path representing the attribute to compare.
     * @param left       The lower bound of the range.
     * @param right      The upper bound of the range.
     * @param sqlDialect The SQL dialect to use for rendering.
     */
    public Bt(Selectable selectable, Selectable left, Selectable right, SqlDialect sqlDialect) {
        this.attribute = selectable;
        this.left = left;
        this.right = right;
        this.sqlDialect = sqlDialect;
    }


    public String toSql() {
        return sqlDialect.escapeIdentifier(attribute.toSql()) + " between " + left.toSql() + " and " + right.toSql();
    }
}
package com.ainouss.jdatatools.query.operator;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Starts with operator
 */
public class EndsWith implements Expression {

    private final Selectable attribute;
    private final Selectable right;
    private final SqlDialect sqlDialect;

    public EndsWith(Selectable attribute, Selectable right, SqlDialect sqlDialect) {
        this.attribute = attribute;
        this.right = right;
        this.sqlDialect = sqlDialect;
    }

    public String toSql() {
        String escaped = right.toSql().replace("'", "");
        return sqlDialect.escapeIdentifier(attribute.toSql()) + " like '%" + escaped + "'";
    }
}
package com.ainouss.jdatatools.query.operator;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Represents the equality operator (=) in a query.
 * <p>
 * This class is used to compare if a value is equal to another value.
 * It can be used with numbers, paths, and strings.
 * <p>
 * Example usage:
 * <pre>
 *  CriteriaBuilder cb = new CriteriaBuilder();
 *  CriteriaQuery<MyEntity> query = cb.createQuery(MyEntity.class);
 *  Root<MyEntity> root = query.from();
 *  query.where(cb.eq(root.get("name"), "John Doe"));
 * </pre>
 * This would generate the following SQL WHERE clause:
 * <pre>
 *  WHERE name = 'John Doe'
 * </pre>
 */
public class Eq implements Expression {

    private final Selectable attribute;
    private final Selectable right;
    private final SqlDialect sqlDialect;

    /**
     * Constructs a new {@code Eq} operator with the given path and value.
     *
     * @param attribute The path representing the attribute to compare.
     * @param right     The value to compare against.
     * @param sqlDialect The SQL dialect to use for rendering.
     */
    public Eq(Selectable attribute, Selectable right, SqlDialect sqlDialect) {
        this.attribute = attribute;
        this.right = right;
        this.sqlDialect = sqlDialect;
    }

    /**
     * Generates the SQL representation of the equality operator.
     *
     * @return The SQL representation of the equality operator.
     * @throws RuntimeException If the operator is used with null or array values.
     */
    public String toSql() {
        return sqlDialect.escapeIdentifier(attribute.toSql()) + " = " + right.toSql();
    }
}
package com.ainouss.jdatatools.query.operator;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Represents the greater than or equal operator (>=) in a query.
 * <p>
 * This class is used to compare if a value is greater than or equal to
 * another value. It can be used with numbers, paths, and strings.
 * <p>
 * Example usage:
 * <pre>
 *  CriteriaBuilder cb = new CriteriaBuilder();
 *  CriteriaQuery<MyEntity> query = cb.createQuery(MyEntity.class);
 *  Root<MyEntity> root = query.from();
 *  query.where(cb.ge(root.get("salary"), 30));
 * </pre>
 * This would generate the following SQL WHERE clause:
 * <pre>
 *  WHERE salary >= 30
 * </pre>
 */
public class Ge implements Expression {

    private final Selectable attribute;
    private final Selectable right;
    private final SqlDialect sqlDialect;

    /**
     * Constructs a new {@code Ge} operator with the given path and value.
     *
     * @param attribute The path representing the attribute to compare.
     * @param right     The value to compare against.
     * @param sqlDialect The SQL dialect to use for rendering.
     */
    public Ge(Selectable attribute, Selectable right, SqlDialect sqlDialect) {
        this.attribute = attribute;
        this.right = right;
        this.sqlDialect = sqlDialect;
    }

    /**
     * Generates the SQL representation of the greater than or equal operator.
     *
     * @return The SQL representation of the operator.
     * @throws RuntimeException If the operator is used with null values.
     */
    public String toSql() {
        return sqlDialect.escapeIdentifier(attribute.toSql()) + " >= " + right.toSql();
    }
}
package com.ainouss.jdatatools.query.operator;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Represents the greater than operator (>) in a query.
 * <p>
 * This class is used to compare if a value is greater than another value.
 * It can be used with numbers, paths, and strings.
 * <p>
 * Example usage:
 * <pre>
 *  CriteriaBuilder cb = new CriteriaBuilder();
 *  CriteriaQuery<MyEntity> query = cb.createQuery(MyEntity.class);
 *  Root<MyEntity> root = query.from();
 *  query.where(
 *      cb.gt(root.get("salary"), 30)
 *  );
 * </pre>
 * This would generate the following SQL WHERE clause:
 * <pre>
 *  WHERE salary > 30
 * </pre>
 */
public class Gt implements Expression {

    private final Selectable attribute;
    private final Selectable right;
    private final SqlDialect sqlDialect;

    /**
     * Constructs a new {@code Gt} operator with the given path and value.
     *
     * @param attribute The attribute representing the attribute to compare.
     * @param right     The value to compare against.
     * @param sqlDialect The SQL dialect to use for rendering.
     */
    public Gt(Selectable attribute, Selectable right, SqlDialect sqlDialect) {
        this.attribute = attribute;
        this.right = right;
        this.sqlDialect = sqlDialect;
    }

    /**
     * Generates the SQL representation of the greater than operator.
     */
    public String toSql() {
        return sqlDialect.escapeIdentifier(attribute.toSql()) + " > " + right.toSql();
    }
}
package com.ainouss.jdatatools.query.operator;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Represents the IN operator in a query.
 * <p>
 * This class is used to check if a value matches any value within a given list
 * or collection. It can be used with numbers, paths, and strings.
 * <p>
 * Example usage 1:
 * <pre>
 *  CriteriaBuilder cb = new CriteriaBuilder();
 *  CriteriaQuery<MyEntity> query = cb.createQuery(MyEntity.class);
 *  Root<MyEntity> root = query.from();
 *  query.where(
 *      cb.inL(
 *          root.get("country"), Arrays.asList("USA", "Canada")
 *      )
 *  );
 * </pre>
 * would generate the following WHERE clause :
 * <pre> WHERE country IN ('USA', 'Canada') </pre>
 * <p>
 * Example usage 2:
 * <pre>
 *  CriteriaBuilder cb = new CriteriaBuilder();
 *  CriteriaQuery<MyEntity> query = cb.createQuery(MyEntity.class);
 *  Root<MyEntity> root = query.from();
 *  query.where(
 *      cb.in(
 *          root.get("country"), "USA", "Canada"
 *      )
 *  );
 * </pre>
 * <p>
 * would generate the following WHERE clause (the same as above):
 * <pre> WHERE country IN ('USA', 'Canada') </pre>
 * Example usage 3:
 * <pre>
 *  CriteriaBuilder cb = new CriteriaBuilder();
 *  CriteriaQuery<MyEntity> query = cb.createQuery(MyEntity.class);
 *  Root<MyEntity> root = query.from();
 *  query.where(
 *      cb.inn(
 *          root.get("country"), List.of()
 *      )
 *  );
 * </pre>
 * This would generate an empty SQL WHERE clause.
 */
public class In implements Expression {

    private final Selectable attribute;
    private final List<Selectable> args = new ArrayList<>();
    private final SqlDialect sqlDialect;

    /**
     * Constructs a new {@code In} operator with the given path and values.
     *
     * @param attribute The attribute representing the attribute to compare.
     * @param args      The collection of values to compare against.
     * @param sqlDialect The SQL dialect to use for rendering.
     * @throws RuntimeException If no values are provided or if the value is null.
     */
    public In(Selectable attribute, Collection<Selectable> args, SqlDialect sqlDialect) {
        this.attribute = attribute;
        this.args.addAll(args);
        this.sqlDialect = sqlDialect;
    }

    /**
     * Generates the SQL representation of the 'IN' operator.
     *
     * @return The SQL representation of the 'IN' operator.
     */
    public String toSql() {
        String values = args.stream()
                .map(Selectable::toSql)
                .collect(Collectors.joining(","));
        return sqlDialect.escapeIdentifier(attribute.toSql()) + " in  (" + values + ")";
    }
}
package com.ainouss.jdatatools.query.operator;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Is not null expression
 */
public class IsNotNull implements Expression {

    private final Selectable attribute;
    private final SqlDialect sqlDialect;

    public IsNotNull(Selectable attribute, SqlDialect sqlDialect) {
        this.attribute = attribute;
        this.sqlDialect = sqlDialect;
    }

    public String toSql() {
        return sqlDialect.escapeIdentifier(attribute.toSql()) + " is not null ";
    }
}
package com.ainouss.jdatatools.query.operator;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * A field with a NULL value is a field with no value.
 */
public class IsNull implements Expression {

    private final Selectable attribute;
    private final SqlDialect sqlDialect;

    public IsNull(Selectable attribute, SqlDialect sqlDialect) {
        this.attribute = attribute;
        this.sqlDialect = sqlDialect;
    }

    public String toSql() {
        return sqlDialect.escapeIdentifier(attribute.toSql()) + " is null ";
    }
}
package com.ainouss.jdatatools.query.operator;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Represents the less than or equal operator (<=) in a query.
 * <p>
 * This class is used to compare if a value is less than or equal to
 * another value. It can be used with numbers and expressions.
 * <p>
 * Example usaLe:
 * <pre>
 *  CriteriaBuilder cb = new CriteriaBuilder();
 *  CriteriaQuery<MyEntity> query = cb.createQuery(MyEntity.class);
 *  Root<MyEntity> root = query.from();
 *  query.where(
 *      cb.le(root.Let("salary"), 30)
 *  );
 * </pre>
 * This would Lenerate the following SQL WHERE clause:
 * <pre>
 *  WHERE salary <= 30
 * </pre>
 */
public class Le implements Expression {

    private final Selectable attribute;
    private final Selectable right;
    private final SqlDialect sqlDialect;

    /**
     * Constructs a new {@code Le} operator with the given path and value.
     *
     * @param attribute The path representing the attribute to compare.
     * @param right     The value to compare against.
     * @param sqlDialect The SQL dialect to use for rendering.
     */
    public Le(Selectable attribute, Selectable right, SqlDialect sqlDialect) {
        this.attribute = attribute;
        this.right = right;
        this.sqlDialect = sqlDialect;
    }

    /**
     * Le generates the SQL representation of the greater than or equal operator.
     *
     * @return The SQL representation of the operator.
     * @throws RuntimeException If the operator is used with null values.
     */
    public String toSql() {
        return sqlDialect.escapeIdentifier(attribute.toSql()) + " <= " + right.toSql();
    }
}
package com.ainouss.jdatatools.query.operator;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Represents the LIKE operator in a query.
 * <p>
 * This class is used for pattern matching against string values.
 * It adds wildcard characters (%) around the provided value to match
 * any substring within the target attribute.
 * <p>
 * Example usage:
 * <pre>
 *  CriteriaBuilder cb = new CriteriaBuilder();
 *  CriteriaQuery<MyEntity> query = cb.createQuery(MyEntity.class);
 *  Root<MyEntity> root = query.from();
 *  query.where(
 *      cb.like(root.get("name"), "John")
 *  );
 * </pre>
 * This would generate the following SQL WHERE clause:
 * <pre>
 *  WHERE name LIKE '%John%'
 * </pre>
 */
public class Like implements Expression {

    private final Selectable attribute;
    private final Selectable right;
    private final SqlDialect sqlDialect;

    /**
     * Constructs a new {@code Like} operator with the given path and value.
     *
     * @param attribute The attribute representing the attribute to compare.
     * @param right     The value used for pattern matching.
     * @param sqlDialect The SQL dialect to use for rendering.
     */
    public Like(Selectable attribute, Selectable right, SqlDialect sqlDialect) {
        this.attribute = attribute;
        this.right = right;
        this.sqlDialect = sqlDialect;
    }

    /**
     * Generates the SQL representation of the LIKE operator.
     *
     * @return The SQL representation of the LIKE operator.
     */
    public String toSql() {
        String escaped = right.toSql().replace("'", "");
        return sqlDialect.escapeIdentifier(attribute.toSql()) + " like '%" + escaped + "%'";
    }
}
package com.ainouss.jdatatools.query.operator;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Represents the less than operator (<) in a query.
 * <p>
 * This class is used to compare if a value is less than another value.
 * It can be used with numbers and expressions.
 * <p>
 * Example usage:
 * <pre>
 *  CriteriaBuilder cb = new CriteriaBuilder();
 *  CriteriaQuery<MyEntity> query = cb.createQuery(MyEntity.class);
 *  Root<MyEntity> root = query.from();
 *  query.where(
 *      cb.lt(root.get("salary"), 30)
 * );
 * </pre>
 * This would generate the following SQL WHERE clause:
 * <pre>
 *  WHERE salary < 30
 * </pre>
 */
public class Lt implements Expression {

    private final Selectable attribute;
    private final Selectable right;
    private final SqlDialect sqlDialect;

    /**
     * Constructs a new {@code Lt} operator with the given path and value.
     *
     * @param attribute The path representing the attribute to compare.
     * @param right     The value to compare against.
     * @param sqlDialect The SQL dialect to use for rendering.
     */
    public Lt(Selectable attribute, Selectable right, SqlDialect sqlDialect) {
        this.attribute = attribute;
        this.right = right;
        this.sqlDialect = sqlDialect;
    }

    /**
     * Lt generates the SQL representation of the greater than or equal operator.
     *
     * @return The SQL representation of the operator.
     * @throws RuntimeException If the operator is used with null values.
     */
    public String toSql() {
        return sqlDialect.escapeIdentifier(attribute.toSql()) + " < " + right.toSql();
    }
}
package com.ainouss.jdatatools.query.operator;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Represents the inequality operator (!=) in a query.
 * <p>
 * This class is used to compare if a value is not equal to another value.
 * It can be used with numbers, paths, and strings.
 * <p>
 * Example usage:
 * <pre>
 *  CriteriaBuilder cb = new CriteriaBuilder();
 *  CriteriaQuery<MyEntity> query = cb.createQuery(MyEntity.class);
 *  Root<MyEntity> root = query.from();
 *  query.where(
 *      cb.ne(root.get("name"), "John Doe")
 *  );
 * </pre>
 * This would generate the following SQL WHERE clause:
 * <pre>
 *  WHERE name != 'John Doe'
 * </pre>
 */
public class Ne implements Expression {

    private final Selectable left;
    private final Selectable right;
    private final SqlDialect sqlDialect;

    public Ne(Selectable left, Selectable right, SqlDialect sqlDialect) {
        this.left = left;
        this.right = right;
        this.sqlDialect = sqlDialect;
    }

    /**
     * Generates the SQL representation of the inequality operator.
     *
     * @return The SQL representation of the inequality operator.
     * @throws RuntimeException If the operator is used with null or array values.
     */
    public String toSql() {
        return sqlDialect.escapeIdentifier(left.toSql()) + " != " + right.toSql();
    }
}
package com.ainouss.jdatatools.query.operator;

import com.ainouss.jdatatools.query.core.Expression;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

/**
 * Starts with operator
 */
public class StartsWith implements Expression {

    private final Selectable attribute;
    private final Selectable right;
    private final SqlDialect sqlDialect;

    public StartsWith(Selectable attribute, Selectable right, SqlDialect sqlDialect) {
        this.attribute = attribute;
        this.right = right;
        this.sqlDialect = sqlDialect;
    }


    public String toSql() {
        String escaped = right.toSql().replace("'", "");
        return sqlDialect.escapeIdentifier(attribute.toSql()) + " like '" + escaped + "%'";
    }

}
package com.ainouss.jdatatools.query.order;

import com.ainouss.jdatatools.query.core.Fragment;
import com.ainouss.jdatatools.query.core.Selectable;
import lombok.Getter;

@Getter
public class Order implements Fragment {

    private final Selectable column;
    private final OrderDirection direction;

    public Order(Selectable column, OrderDirection direction) {
        this.column = column;
        this.direction = direction;
    }

    public Order(Selectable column) {
        this.column = column;
        this.direction = OrderDirection.ASC;
    }

    @Override
    public String toSql() {
        return column.toSql() + " " + direction;
    }
}
package com.ainouss.jdatatools.query.order;

public enum OrderDirection {
    ASC,
    DESC
}

package com.ainouss.jdatatools.query.registery;

import com.ainouss.jdatatools.query.core.*;
import jakarta.persistence.Column;
import jakarta.persistence.Table;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.reflect.FieldUtils;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.stream.Collectors;

import static com.ainouss.jdatatools.query.util.DataUtils.isNotBlank;

/**
 * Creates a criteria builder and holds column names and table names
 */
@Component
@Slf4j
public class EntityRegistry {
    /**
     * columns from @Column annotation
     */
    public static final LinkedHashMap<Path<?>, String> paths = new LinkedHashMap<>();
    /**
     * tables from @Table annotation
     */
    public static final LinkedHashMap<Root<?>, String> roots = new LinkedHashMap<>();

    private static final HashSet<Class<?>> registered = new HashSet<>();


    public EntityRegistry(EntityResolver resolver) {
        resolver
                .resolve()
                .forEach(this::register);
    }

    /**
     * Entry criteria builder
     *
     * @return criteria builder
     */
    public static CriteriaBuilder criteriaBuilder() {
        return new CriteriaBuilder();
    }

    /**
     * Scan the class for table name & columns
     *
     * @param clazz input
     */
    public void register(Class<?> clazz) {
        registerClass(clazz);
    }

    /**
     * Register class
     *
     * @param clazz input
     */
    public static void registerClass(Class<?> clazz) {
        if (registered.contains(clazz)) {
            return;
        }
        Root<?> root = new Root<>(clazz);
        roots.put(root, getTableName(clazz));
        getSelectableFields(clazz)
                .forEach(field -> paths.put(new Path<>(root, field.getLabel()), field.getColumn()));
        registered.add(clazz);
    }

    private static String getTableName(Class<?> model) {
        if (model == null) {
            throw new RuntimeException("Target class should not be null");
        }
        Table annotation = AnnotationUtils.findAnnotation(model, Table.class);
        if (annotation == null) {
            String message = String.format("Target class %s should be annotated with annotation %s", model, Table.class);
            throw new RuntimeException(message);
        }
        return annotation.name();
    }


    /**
     * Resolve path to a column name, all paths are known before the query execution
     *
     * @return column name
     */
    public static String fullResolve(Expression selectable) {
        if (selectable == null) {
            return "";
        }
        if (selectable instanceof Root<?> root) {
            return resolveRoot(root);
        }
        if (selectable instanceof Path<?> path) {
            return fullResolvePath(path);
        }
        return selectable.toSql();
    }

    public static String fullResolvePath(Path<?> path) {
        String root = resolveRoot(path.getHead());
        String col = resolvePath(path);
        return root + "." + (isNotBlank(col) ? col : path.getAttribute());
    }

    public static String resolvePath(Path<?> path) {
        String col = paths.get(path);
        return (isNotBlank(col) ? col : path.getAttribute());
    }

    /**
     * Resolve root to a column name, all paths are known before the query execution
     *
     * @param root root
     * @return column name
     */
    public static String resolveRoot(Root<?> root) {
        if (root == null) {
            return "";
        }
        if (isNotBlank(root.getAlias())) {
            return root.getAlias();
        }
        String table = roots.get(root);
        if (table == null) {
            throw new RuntimeException("Could not locate table for root, make sure to add @Column annotation" + root);
        }
        return table;
    }

    /**
     * List of selectable fields for a given class
     *
     * @param clazz class
     * @return fields
     */
    public static List<FieldMetaData> getSelectableFields(Class<?> clazz) {
        return Arrays.stream(
                        FieldUtils.getFieldsWithAnnotation(clazz, Column.class)
                )
                .map(field -> {
                    FieldMetaData fieldMetaData = new FieldMetaData();
                    fieldMetaData.setLabel(field.getName());
                    fieldMetaData.setColumn(field.getAnnotation(Column.class).name());
                    fieldMetaData.setJavaType(field.getType());
                    return fieldMetaData;
                })
                .sorted(Comparator.comparing(FieldMetaData::getLabel))
                .collect(Collectors.toList());
    }

}

package com.ainouss.jdatatools.query.registery;

import java.util.List;

/**
 * Define an abstract way to load entities
 */
@FunctionalInterface
public interface EntityResolver {
    /**
     * Defines a supplier to get the model
     *
     * @return list of classes
     */
    List<Class<?>> resolve();

}

package com.ainouss.jdatatools.query.registery;

import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class SampleEntityResolver implements EntityResolver {

    private final List<Class<?>> entities;

    public SampleEntityResolver(List<Class<?>> entities) {
        this.entities = entities;
    }

    @Override
    public List<Class<?>> resolve() {
        return entities;
    }
}

package com.ainouss.jdatatools.query.setoperation;

import com.ainouss.jdatatools.query.core.CriteriaQuery;

public class Except implements SetOperation {

    private final CriteriaQuery<?> other;

    public Except(CriteriaQuery<?> other) {
        this.other = other;
    }

    public String toSql() {
        return "except (" + other.buildSelectQuery() + ")";
    }

}
package com.ainouss.jdatatools.query.setoperation;

import com.ainouss.jdatatools.query.core.CriteriaQuery;

public class Intersect implements SetOperation {

    private final CriteriaQuery<?> other;

    public Intersect(CriteriaQuery<?> other) {
        this.other = other;
    }

    public String toSql() {
        return "intersect (" + other.buildSelectQuery() + ")";
    }

}
package com.ainouss.jdatatools.query.setoperation;

import com.ainouss.jdatatools.query.core.Fragment;

public interface SetOperation extends Fragment {
}
package com.ainouss.jdatatools.query.setoperation;

import com.ainouss.jdatatools.query.core.CriteriaQuery;

public class Union implements SetOperation {

    private final CriteriaQuery<?> other;

    public Union(CriteriaQuery<?> other) {
        this.other = other;
    }

    public String toSql() {
        return "union (" + other.buildSelectQuery()+ ")";
    }


}
package com.ainouss.jdatatools.query.setoperation;

import com.ainouss.jdatatools.query.core.CriteriaQuery;

public class UnionAll implements SetOperation {

    private final CriteriaQuery<?> other;

    public UnionAll(CriteriaQuery<?> other) {
        this.other = other;
    }

    public String toSql() {
        return "union all (" + other.buildSelectQuery() + ")";
    }

}
package com.ainouss.jdatatools.query.subquery;


import com.ainouss.jdatatools.query.core.CriteriaQuery;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

public class All implements Selectable {

    private final CriteriaQuery<?> subquery; // Subquery is now a local variable
    private final SqlDialect sqlDialect;

    public All(CriteriaQuery<?> subquery, SqlDialect sqlDialect) {
        this.subquery = subquery;
        this.sqlDialect = sqlDialect;
    }

    public All(CriteriaQuery<?> subquery) { // For CriteriaBuilder default constructor
        this(subquery, null);
    }


    @Override
    public String toSql() {
        return " all (" + subquery.buildSelectQuery() + ")";
    }

    @Override
    public void setAlias(String alias) {
        //
    }

    @Override
    public String getAlias() {
        return "";
    }

    public SqlDialect getSqlDialect() {
        return sqlDialect;
    }
}
package com.ainouss.jdatatools.query.subquery;


import com.ainouss.jdatatools.query.core.CriteriaQuery;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

public class Any implements Selectable {

    private final CriteriaQuery<?> subquery; // Subquery is now a local variable
    private final SqlDialect sqlDialect;

    public Any(CriteriaQuery<?> subquery, SqlDialect sqlDialect) {
        this.subquery = subquery;
        this.sqlDialect = sqlDialect;
    }

    public Any(CriteriaQuery<?> subquery) { // For CriteriaBuilder default constructor
        this(subquery, null);
    }


    @Override
    public String toSql() {
        return " any (" + subquery.buildSelectQuery() + ")";
    }

    @Override
    public void setAlias(String alias) {
        //
    }

    @Override
    public String getAlias() {
        return "";
    }

    public SqlDialect getSqlDialect() {
        return sqlDialect;
    }
}
package com.ainouss.jdatatools.query.subquery;


import com.ainouss.jdatatools.query.core.CriteriaQuery;
import com.ainouss.jdatatools.query.core.Selectable;
import com.ainouss.jdatatools.query.dialect.SqlDialect;

public class Exists implements Selectable {

    private final CriteriaQuery<?> subquery; // Subquery is now a local variable
    private final SqlDialect sqlDialect;

    public Exists(CriteriaQuery<?> subquery, SqlDialect sqlDialect) {
        this.subquery = subquery;
        this.sqlDialect = sqlDialect;
    }

    public Exists(CriteriaQuery<?> subquery) { // For CriteriaBuilder default constructor
        this(subquery, null);
    }


    @Override
    public String toSql() {
        return " exists (" + subquery.buildSelectQuery() + ")";
    }

    @Override
    public void setAlias(String alias) {
        //
    }

    @Override
    public String getAlias() {
        return "";
    }

    public SqlDialect getSqlDialect() {
        return sqlDialect;
    }
}
package com.ainouss.jdatatools.query.util;


public final class DataUtils {

    public static <T extends CharSequence> boolean isBlank(T s) {
        if (s == null) {
            return true;
        }
        return skipSpaceTab(s, s.length()) == s.length();
    }

    public static boolean isNotBlank(String s) {
        if (s == null) {
            return false;
        }
        return trimToNull(s) != null;
    }

    private static int skipSpaceTab(CharSequence s, int endIndex) {
        for (int i = 0; i < endIndex; i++) {
            switch (s.charAt(i)) {
                case ' ':
                case '\t':
                    break;
                default:
                    return i;
            }
        }
        return endIndex;
    }
    public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {
        return isBlank(str) ? defaultStr : str;
    }
    public static String trimToNull(String s) {
        if (s == null) {
            return null;
        }
        String trimmed = s.trim();
        return trimmed.isEmpty() ? null : trimmed;
    }

    public static String trimToBlank(String s) {
        String s1 = trimToNull(s);
        if (s1 == null) {
            return "";
        }
        return s1;
    }


    public static String escapeSql(String str) {
        if (str == null) {
            return null;
        }
        return str.replace("'", "''");
    }
}

package com.ainouss.jdatatools.query.core;

import com.ainouss.jdatatools.query.model.Employee;
import com.ainouss.jdatatools.query.model.EmployeeDetails;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;

@ExtendWith(SpringExtension.class)
class CriteriaBuilderTest {

    private final CriteriaBuilder cb = new CriteriaBuilder();

    @Test
    void createQuery() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String actual = query
                .select(root)
                .buildSelectQuery();
        assertEquals("select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES", actual);
    }

    @Test
    void like() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.like(root.get("lastName"), "some lastName").toSql();
        assertEquals("EMPLOYEES.LAST_NAME like '%some lastName%'", sql);
    }

    @Test
    void endsWith() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.endsWith(root.get("lastName"), "doe").toSql();
        assertEquals("EMPLOYEES.LAST_NAME like '%doe'", sql);
    }

    @Test
    void startsWith() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.startsWith(root.get("lastName"), "john").toSql();
        assertEquals("EMPLOYEES.LAST_NAME like 'john%'", sql);
    }

    @Test
    void eq() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.eq(root.get("lastName"), "john").toSql();
        assertEquals("EMPLOYEES.LAST_NAME = 'john'", sql);
    }


    @Test
    void gt() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Employee employee = new Employee();
        employee.setSalary(25);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.gt(root.get("salary"), employee.getSalary()).toSql();
        assertEquals("EMPLOYEES.SALARY > 25", sql);
    }

    @Test
    void lt() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Employee employee = new Employee();
        employee.setSalary(25);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.lt(root.get("salary"), employee.getSalary()).toSql();
        assertEquals("EMPLOYEES.SALARY < 25", sql);
    }

    @Test
    void le() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Employee employee = new Employee();
        employee.setSalary(25);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.le(root.get("salary"), employee.getSalary()).toSql();
        assertEquals("EMPLOYEES.SALARY <= 25", sql);
    }

    @Test
    void ge() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Employee employee = new Employee();
        employee.setSalary(25);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.ge(root.get("salary"), employee.getSalary()).toSql();
        assertEquals("EMPLOYEES.SALARY >= 25", sql);
    }

    @Test
    void inL() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.inL(root.get("lastName"), List.of("john", "jane")).toSql();
        assertEquals("EMPLOYEES.LAST_NAME in  ('john','jane')", sql);
    }

    @Test
    void in() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.in(root.get("lastName"), "john", "jane").toSql();
        assertEquals("EMPLOYEES.LAST_NAME in  ('john','jane')", sql);
    }

    @Test
    void inn() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.inn(root.get("lastName"), List.of()).toSql();
        assertEquals("", sql);
    }

    @Test
    void between() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.between(root.get("salary"), 10, 20).toSql();
        assertEquals("EMPLOYEES.SALARY between 10 and 20", sql);
    }

    @Test
    void isNotNull() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.isNotNull(root.get("lastName")).toSql();
        assertEquals("EMPLOYEES.LAST_NAME is not null ", sql);
    }

    @Test
    void isNull() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.isNull(root.get("lastName")).toSql();
        assertEquals("EMPLOYEES.LAST_NAME is null ", sql);
    }

    @Test
    void and() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.and(
                cb.eq(root.get("firstName"), "John"),
                cb.eq(root.get("lastName"), "doe")
        ).toSql();
        assertEquals("(EMPLOYEES.FIRST_NAME = 'John' and EMPLOYEES.LAST_NAME = 'doe')", sql);
    }

    @Test
    void or() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.or(
                cb.eq(root.get("firstName"), "John"),
                cb.eq(root.get("lastName"), "doe")
        ).toSql();
        assertEquals("(EMPLOYEES.FIRST_NAME = 'John' or EMPLOYEES.LAST_NAME = 'doe')", sql);
    }

    @Test
    void not() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.not(
                cb.eq(root.get("firstName"), "John"),
                cb.eq(root.get("lastName"), "doe")
        ).toSql();
        assertEquals("not ((EMPLOYEES.FIRST_NAME = 'John' and EMPLOYEES.LAST_NAME = 'doe'))", sql);
    }

    @Test
    void max() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.max(root.get("salary")).toSql();
        assertEquals("max(EMPLOYEES.SALARY)", sql);
    }

    @Test
    void min() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.min(root.get("salary")).toSql();
        assertEquals("min(EMPLOYEES.SALARY)", sql);
    }


    @Test
    void sum() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.sum(root.get("salary")).toSql();
        assertEquals("sum(EMPLOYEES.SALARY)", sql);
    }

    @Test
    void avg() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.avg(root.get("salary")).toSql();
        assertEquals("avg(EMPLOYEES.SALARY)", sql);
    }

    @Test
    void count() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.count(root.get("salary")).toSql();
        assertEquals("count(EMPLOYEES.SALARY)", sql);
    }

    @Test
    void distinct() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.distinct(root.get("salary")).toSql();
        assertEquals("distinct EMPLOYEES.SALARY", sql);
    }

    @Test
    void sum_over() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.sum(root.get("salary")).over().partitionBy(root.get("departmentId")).toSql();
        assertEquals("sum(EMPLOYEES.SALARY) over (partition by EMPLOYEES.departmentId)", sql);
    }

    @Test
    void rank() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.rank().over().partitionBy(root.get("departmentId")).orderBy(root.get("salary").asc()).toSql();
        assertEquals("rank() over (partition by EMPLOYEES.departmentId order by EMPLOYEES.SALARY ASC)", sql);
    }

    @Test
    void row_number() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.rowNumber().over().partitionBy(root.get("departmentId")).orderBy(root.get("salary").asc()).toSql();
        assertEquals("row_number() over (partition by EMPLOYEES.departmentId order by EMPLOYEES.SALARY ASC)", sql);
    }

    @Test
    void ne() {
        CriteriaBuilder cb = new CriteriaBuilder();
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.ne(root.get("name"), "John Doe").toSql();
        assertEquals("EMPLOYEES.name != 'John Doe'", sql);
    }

    @Test
    void aggregate_function() {
        CriteriaBuilder cb = new CriteriaBuilder();
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> emp = query.from(Employee.class).as("tbl");
        String sql = cb.gt(cb.sum(emp.get("salary")), 1000L).toSql();
        assertEquals("sum(tbl.SALARY) > 1000", sql);
    }

    @Test
    void simple_case() {
        CriteriaBuilder cb = new CriteriaBuilder();
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> emp = query.from(Employee.class).as("tbl");
        String sql =
                cb.choice(emp.get("salary"))
                        .when(100)
                        .then("slave")
                        .when(200)
                        .then("employee")
                        .otherwise("rich")
                        .as("status")
                        .toSql();
        assertEquals("case tbl.SALARY when 100 then 'slave' when 200 then 'employee' else 'rich' end", sql);
    }

    @Test
    void searched_case() {
        CriteriaBuilder cb = new CriteriaBuilder();
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> emp = query.from(Employee.class).as("tbl");
        String sql =
                cb.choice()
                        .when(cb.eq(emp.get("salary"), 100))
                        .then("slave")
                        .when(cb.eq(emp.get("salary"), 200))
                        .then("employee")
                        .otherwise("rich")
                        .as("status")
                        .toSql();
        assertEquals("case when tbl.SALARY = 100 then 'slave' when tbl.SALARY = 200 then 'employee' else 'rich' end", sql);
    }

    @Test
    void nested_case() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> emp = query.from(Employee.class);
        String sql = cb.choice()
                .when(cb.gt(emp.get("age"), 60))
                .then("Retired")
                .otherwise(
                        cb.choice(emp.get("departmentId"))  // Inner Simple CASE
                                .whenThen(1, "Sales")
                                .whenThen(2, "Marketing")
                                .otherwise("Other")

                ).end().as("status").toSql();
        assertEquals("case when EMPLOYEES.age > 60 then 'Retired' else case EMPLOYEES.departmentId when 1 then 'Sales' when 2 then 'Marketing' else 'Other' end end", sql);
    }

    @Test
    void with_cte() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> root = cr.from(Employee.class);
        String sql = cb.with("my_query").as(
                cr.select()
                        .from(root)
        ).toSql();
        assertEquals("with my_query as (select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES)", sql);
    }

    @Test
    public void test_joins() {
        CriteriaQuery<Employee> q1 = cb.createQuery(Employee.class);
        Root<Employee> emp = q1.from(Employee.class).as("emp");

        CriteriaQuery<EmployeeDetails> q2 = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> det = q2.from(EmployeeDetails.class).as("det");

        String sql = emp.leftJoin(det).on(cb.eq(emp.get("id"), det.get("id")))
                .rightJoin(det).on(cb.eq(emp.get("id"), det.get("id"))).toSql();
        assertEquals("EMPLOYEES emp left join EMPLOYEE_DETAILS det on emp.ID = det.ID  right join EMPLOYEE_DETAILS det on emp.ID = det.ID", sql);
    }
}
package com.ainouss.jdatatools.query.core;

import com.ainouss.jdatatools.query.dialect.StandardDialect;
import com.ainouss.jdatatools.query.logical.AbstractExpression;
import com.ainouss.jdatatools.query.model.Department;
import com.ainouss.jdatatools.query.model.Employee;
import com.ainouss.jdatatools.query.model.EmployeeDetails;
import com.ainouss.jdatatools.query.order.OrderDirection;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;


@ExtendWith(SpringExtension.class)
class CriteriaQueryTest {

    private final CriteriaBuilder cb = new CriteriaBuilder();


    @Test
    public void should__simple_query() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");

        cr.select(rt.get("id"), rt.get("lastName"))
                .from(rt)
                .where(
                        cb.and(
                                cb.gt(rt.get("id"), 0),
                                cb.lt(rt.get("id"), 30),
                                cb.gt(rt.get("id"), 10),
                                cb.lt(rt.get("id"), 20),
                                cb.gt(rt.get("id"), 17),
                                cb.lt(rt.get("id"), 19)
                        ));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.ID as id,tbl.LAST_NAME as lastName from EMPLOYEES tbl where ((tbl.ID > 0 and tbl.ID < 30 and tbl.ID > 10 and tbl.ID < 20 and tbl.ID > 17 and tbl.ID < 19))", select);
    }

    @Test
    public void should__complex_criteria() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr
                .select(rt)
                .where(
                        cb.and(
                                        cb.eq(rt.get("firstName"), "XYZ"),
                                        cb.like(rt.get("salary"), "TEST"),
                                        cb.isNull(rt.get("lastName")),
                                        cb.isNotNull(rt.get("enabled"))
                                )
                                .or(
                                        cb.and(
                                                cb.eq(rt.get("firstName"), "ABCD"),
                                                cb.eq(rt.get("id"), 1000)
                                        )
                                )
                                .or(
                                        cb.and(
                                                cb.eq(rt.get("firstName"), "ABBFSTO"),
                                                cb.or(
                                                        cb.eq(rt.get("id"), 15),
                                                        cb.between(rt.get("id"), 5, 1000)
                                                )

                                        )
                                )
                );

        String select = cr
                .select(rt)
                .buildSelectQuery();
        Assertions.assertEquals("select tbl.ENABLED as enabled,tbl.FIRST_NAME as firstName,tbl.ID as id,tbl.LAST_NAME as lastName,tbl.SALARY as salary from EMPLOYEES tbl where ((tbl.FIRST_NAME = 'XYZ' and tbl.SALARY like '%TEST%' and tbl.LAST_NAME is null and tbl.ENABLED is not null ) or ((tbl.FIRST_NAME = 'ABCD' and tbl.ID = 1000) or (tbl.FIRST_NAME = 'ABBFSTO' and (tbl.ID = 15 or tbl.ID between 5 and 1000))))", select);
    }

    @Test
    public void should__select_with_complex_where() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr
                .select(rt)
                .where(
                        cb.and(
                                cb.gt(rt.get("id"), 10),
                                cb.lt(rt.get("id"), 20),
                                cb.gt(rt.get("id"), 10),
                                cb.lt(rt.get("id"), 1000)
                        ).or(
                                cb.and(
                                        cb.gt(rt.get("id"), 55),
                                        cb.lt(rt.get("id"), 99)

                                )
                        )
                );
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.ENABLED as enabled,tbl.FIRST_NAME as firstName,tbl.ID as id,tbl.LAST_NAME as lastName,tbl.SALARY as salary from EMPLOYEES tbl where ((tbl.ID > 10 and tbl.ID < 20 and tbl.ID > 10 and tbl.ID < 1000) or ((tbl.ID > 55 and tbl.ID < 99)))", select);
    }


    @Test
    public void should__gt_with_expression() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr.select(
                rt.get("id"),
                rt.get("firstName")
        ).where(
                cb.gt(rt.get("id"), rt.get("firstName"))
        );
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.FIRST_NAME as firstName,tbl.ID as id from EMPLOYEES tbl where (tbl.ID > tbl.FIRST_NAME)", select);
    }

    @Test
    public void should__order_by() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        var query = cr.select(
                rt.get("id"),
                rt.get("firstName")
        ).orderBy(
                rt.get("id"), OrderDirection.ASC
        );
        String select = query.buildSelectQuery();
        Assertions.assertEquals("select tbl.FIRST_NAME as firstName,tbl.ID as id from EMPLOYEES tbl order by tbl.ID ASC", select);
    }

    @Test
    public void should__order_by_asc() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        var query = cr.select(
                rt.get("id"),
                rt.get("firstName")
        ).orderBy(
                rt.get("id").asc()
        );
        String select = query.buildSelectQuery();
        Assertions.assertEquals("select tbl.FIRST_NAME as firstName,tbl.ID as id from EMPLOYEES tbl order by tbl.ID ASC", select);
    }

    @Test
    public void should__order_by_des() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        var query = cr.select(
                rt.get("id"),
                rt.get("firstName")
        ).orderBy(
                rt.get("id").desc()
        );
        String select = query.buildSelectQuery();
        Assertions.assertEquals("select tbl.FIRST_NAME as firstName,tbl.ID as id from EMPLOYEES tbl order by tbl.ID ASC", select);
    }

    @Test
    public void should__eq_with_expression() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr.select(
                rt.get("id"),
                rt.get("firstName")
        ).where(
                cb.eq(rt.get("id"), rt.get("firstName"))
        );
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.FIRST_NAME as firstName,tbl.ID as id from EMPLOYEES tbl where (tbl.ID = tbl.FIRST_NAME)", select);
    }

    @Test
    public void should__left_join() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        Root<EmployeeDetails> det = cr.from(EmployeeDetails.class).as("det");
        AbstractExpression where = cb.and(
                cb.eq(det.get("id"), 0),
                cb.gt(rt.get("id"), 1)
        );
        cr
                .select(rt)
                .from(rt.leftJoin(det)
                        .on(
                                cb.eq(rt.get("id"), det.get("id"))
                        ))
                .where(where);
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.ENABLED as enabled,tbl.FIRST_NAME as firstName,tbl.ID as id,tbl.LAST_NAME as lastName,tbl.SALARY as salary from EMPLOYEES tbl left join EMPLOYEE_DETAILS det on tbl.ID = det.ID where ((det.ID = 0 and tbl.ID > 1))", select);
    }

    @Test
    public void should__left_join_with_schema() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class)
                .schema("DB")
                .as("tbl");
        Root<EmployeeDetails> det = cr.from(EmployeeDetails.class)
                .schema("DB2")
                .as("det");

        AbstractExpression and = cb.and(
                cb.eq(det.get("id"), 0),
                cb.gt(rt.get("id"), 1)
        );
        cr
                .select(rt)
                .from(rt.leftJoin(det)
                        .on(
                                cb.eq(rt.get("id"), det.get("id"))
                        )).where(and);
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.ENABLED as enabled,tbl.FIRST_NAME as firstName,tbl.ID as id,tbl.LAST_NAME as lastName,tbl.SALARY as salary from DB.EMPLOYEES tbl left join DB2.EMPLOYEE_DETAILS det on tbl.ID = det.ID where ((det.ID = 0 and tbl.ID > 1))", select);
    }

    @Test
    void testSubqueryInJoinCondition() {

        CriteriaBuilder cb = new CriteriaBuilder();

        CriteriaQuery<Employee> employeeQuery = cb.createQuery(Employee.class);
        Root<Employee> employee = employeeQuery.from(Employee.class).as("e");

        Root<Department> department = employeeQuery.from(Department.class).as("d");

        CriteriaQuery<EmployeeDetails> subquery = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> details = subquery.from(EmployeeDetails.class);

        subquery.select(details.get("departmentId")) // Select department_id
                .where(cb.eq(details.get("employeeId"), employee.get("id")));  // Correlate with outer query


        employeeQuery.select(employee.get("lastName"), department.get("name"))
                .from(employee.join(department).on(subquery));// Select names

        String sql = employeeQuery.buildSelectQuery();
        assertEquals("select e.LAST_NAME as lastName,d.NAME as name from EMPLOYEES e cross join DEPARTMENTS d on (select EMPLOYEE_DETAILS.DEPARTMENT_ID as departmentId from EMPLOYEE_DETAILS EMPLOYEE_DETAILS where (EMPLOYEE_DETAILS.EMPLOYEE_ID = e.ID))", sql);
    }

    @Test
    public void should__select_max() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr.select(cb.max(rt.get("id")));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select max(tbl.ID) from EMPLOYEES tbl", select);
    }

    @Test
    public void should__select_min() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr.select(cb.min(rt.get("id")));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select min(tbl.ID) from EMPLOYEES tbl", select);
    }


    @Test
    public void should__select_sum() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr.select(cb.sum(rt.get("id")));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select sum(tbl.ID) from EMPLOYEES tbl", select);
    }

    @Test
    public void should__select_avg() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr.select(cb.avg(rt.get("id")));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select avg(tbl.ID) from EMPLOYEES tbl", select);
    }

    @Test
    public void should__full_join() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        Root<EmployeeDetails> det = cr.from(EmployeeDetails.class).as("det");

        cr.select(rt.get("id"))
                .from(rt.fullJoin(det)
                        .on(
                                cb.eq(rt.get("id"), det.get("id"))
                        ));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.ID as id from EMPLOYEES tbl full join EMPLOYEE_DETAILS det on tbl.ID = det.ID", select);
    }

    @Test
    public void should__inner_join() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        Root<EmployeeDetails> det = cr.from(EmployeeDetails.class).as("det");

        cr
                .from(
                        rt.innerJoin(det)
                                .on(
                                        cb.eq(rt.get("id"), det.get("id"))
                                )
                )
                .select(rt.get("id"));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.ID as id from EMPLOYEES tbl inner join EMPLOYEE_DETAILS det on tbl.ID = det.ID", select);
    }

    @Test
    public void should__cross_join() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        Root<EmployeeDetails> det = cr.from(EmployeeDetails.class).as("det");

        cr
                .select(rt.get("id"))
                .from(rt.join(det));

        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.ID as id from EMPLOYEES tbl cross join EMPLOYEE_DETAILS det", select);
    }

    @Test
    public void should__complex_join() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        Root<EmployeeDetails> det = cr.from(EmployeeDetails.class).as("det");

        cr.select(rt.get("id"))
                .from(
                        rt.leftJoin(det).on(cb.eq(rt.get("id"), det.get("id")))
                                .rightJoin(det).on(cb.eq(rt.get("id"), det.get("id"))
                                ));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.ID as id from EMPLOYEES tbl left join EMPLOYEE_DETAILS det on tbl.ID = det.ID right join EMPLOYEE_DETAILS det on tbl.ID = det.ID", select);
    }

    @Test
    public void should__not_operation() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        Expression not = cb.not(
                cb.eq(
                        rt.get("id"), 3
                )
                , (
                        cb.not(
                                cb.eq(rt.get("id"), 4)
                        )
                )
        );
        CriteriaQuery<?> criteria = cr
                .select(rt)
                .where(not);
        String select = criteria.buildSelectQuery();
        Assertions.assertEquals("select tbl.ENABLED as enabled,tbl.FIRST_NAME as firstName,tbl.ID as id,tbl.LAST_NAME as lastName,tbl.SALARY as salary from EMPLOYEES tbl where (not ((tbl.ID = 3 and not ((tbl.ID = 4)))))", select);
    }

    @Test
    public void should__in_operation() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr
                .select(rt)
                .where(
                        cb.in(
                                rt.get("id"), 3, 4, 5
                        )

                );
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.ENABLED as enabled,tbl.FIRST_NAME as firstName,tbl.ID as id,tbl.LAST_NAME as lastName,tbl.SALARY as salary from EMPLOYEES tbl where (tbl.ID in (3,4,5))", select);
    }

    @Test
    public void should__inn_operation() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr
                .select(rt)
                .where(
                        cb.inn(
                                rt.get("id"), List.of()
                        )

                );
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.ENABLED as enabled,tbl.FIRST_NAME as firstName,tbl.ID as id,tbl.LAST_NAME as lastName,tbl.SALARY as salary from EMPLOYEES tbl", select);
    }

    @Test
    public void should__delete_query() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        AbstractExpression and = cb.and(
                cb.gt(rt.get("id"), 0),
                cb.lt(rt.get("id"), 30),
                cb.gt(rt.get("id"), 10),
                cb.lt(rt.get("id"), 20),
                cb.gt(rt.get("id"), 17),
                cb.lt(rt.get("id"), 19)
        );
        cr
                .select(rt)
                .where(and);
        String select = cr.buildDeleteQuery();
        Assertions.assertEquals("delete from EMPLOYEES tbl where ((tbl.ID > 0 and tbl.ID < 30 and tbl.ID > 10 and tbl.ID < 20 and tbl.ID > 17 and tbl.ID < 19))", select);
    }

    @Test
    public void should__select_ends_with_str() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr.select(rt.get("firstName"))
                .where(cb.endsWith(rt.get("firstName"), "ABC"));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.FIRST_NAME as firstName from EMPLOYEES tbl where (tbl.FIRST_NAME like '%ABC')", select);
    }

    @Test
    public void should__select_starts_with_str() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr.select(rt.get("firstName"))
                .where(cb.startsWith(rt.get("firstName"), "ABC"));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.FIRST_NAME as firstName from EMPLOYEES tbl where (tbl.FIRST_NAME like 'ABC%')", select);
    }

    @Test
    public void should__select_count_path() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr.select(cb.count(rt.get("firstName")));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select count(tbl.FIRST_NAME) from EMPLOYEES tbl", select);
    }

    @Test
    public void should__select_count_all() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr.select(cb.count(rt));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select count(*) from EMPLOYEES tbl", select);
    }

    @Test
    public void should__select_distinct() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr.select(cb.distinct(rt.get("id")));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select distinct tbl.ID from EMPLOYEES tbl", select);
    }

    @Test
    public void should__select_from_schema() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class)
                .schema("DB")
                .as("tbl");

        cr.select(rt.get("id"));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select tbl.ID as id from DB.EMPLOYEES tbl", select);
    }

    @Test
    public void should__select_count_distinct() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        cr.select(cb.count(cb.distinct(rt.get("id"))));
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select count(distinct tbl.ID) from EMPLOYEES tbl", select);
    }

    @Test
    public void should__group_by_with_count() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> rt = cr.from(Employee.class).as("tbl");
        Path<Employee> id = rt.get("id");
        cr.select(id, cb.count(rt.get("firstName")))
                .where(cb.gt(id, 3))
                .groupBy(id)
                .orderBy(id);
        String select = cr.buildSelectQuery();
        Assertions.assertEquals("select count(tbl.FIRST_NAME),tbl.ID as id from EMPLOYEES tbl where (tbl.ID > 3) group by tbl.ID order by tbl.ID ASC", select);
    }

    @Test
    void should__having() {
        CriteriaBuilder cb = new CriteriaBuilder();
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> emp = query.from(Employee.class).as("tbl");

        String sql = query
                .select(emp)
                .having(cb.gt(cb.avg(emp.get("salary")), 30)).buildSelectQuery();
        assertEquals("select tbl.ENABLED as enabled,tbl.FIRST_NAME as firstName,tbl.ID as id,tbl.LAST_NAME as lastName,tbl.SALARY as salary from EMPLOYEES tbl having avg(tbl.SALARY) > 30", sql);
    }

    @Test
    void should__group__by__having() {
        CriteriaBuilder cb = new CriteriaBuilder();
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> root = cr.from(Employee.class).as("tbl");

        String sql = cr
                .select(root.get("id"))
                .groupBy(root.get("salary"))
                .having(cb.gt(cb.avg(root.get("salary")), 30))
                .buildSelectQuery();

        assertEquals("select tbl.ID as id from EMPLOYEES tbl group by tbl.SALARY having avg(tbl.SALARY) > 30", sql);
    }

    @Test
    public void should_generate_insert_one_field() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        var rt = cr.from(Employee.class);
        cr.select(rt.get("id"));
        String insert = cr.buildInsertQuery();
        Assertions.assertEquals("insert into EMPLOYEES (ID) values (:id)", insert);
    }

    @Test
    public void should_generate_insert_multiple_fields() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        var rt = cr.from(Employee.class);
        cr.select(rt.get("id"), rt.get("firstName"));
        String insert = cr.buildInsertQuery();
        Assertions.assertEquals("insert into EMPLOYEES (ID,FIRST_NAME) values (:id,:firstName)", insert);
    }

    @Test
    public void should_generate_insert_all_fields() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        String insert = cr
                .select(cr.from(Employee.class))
                .buildInsertQuery();
        Assertions.assertEquals("insert into EMPLOYEES (ENABLED,FIRST_NAME,ID,LAST_NAME,SALARY) values (:enabled,:firstName,:id,:lastName,:salary)", insert);
    }

    // @Test()
    public void should_insert_with_table_name_mapper() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        //cr.from(s -> "tab_" + s);
        String insert = cr.buildInsertQuery();
        Assertions.assertEquals("insert into tab_EMPLOYEES (ENABLED,FIRST_NAME,ID,LAST_NAME,SALARY) values (:enabled,:firstName,:id,:lastName,:salary)", insert);
    }

    //@Test
    public void should_insert_with_prefix_2() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        //cr.prefix("tab_");
        String insert = cr.buildInsertQuery();
        Assertions.assertEquals("insert into tab_EMPLOYEES (ENABLED,FIRST_NAME,ID,LAST_NAME,SALARY) values (:enabled,:firstName,:id,:lastName,:salary)", insert);
    }

    @Test
    public void exists_subquery() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class).as("emp");
        //
        CriteriaQuery<EmployeeDetails> sub = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> subRoot = sub.from(EmployeeDetails.class).as("pro");
        //
        String sql = query
                .select(root)
                .where(
                        cb.exists(sub
                                .select(subRoot)
                                .where(cb.eq(root.get("id"), subRoot.get("id")))
                        )
                ).buildSelectQuery();
        assertEquals("select emp.ENABLED as enabled,emp.FIRST_NAME as firstName,emp.ID as id,emp.LAST_NAME as lastName,emp.SALARY as salary from EMPLOYEES emp where ( exists (select pro.DEPARTMENT_ID as departmentId,pro.EMPLOYEE_ID as employeeId,pro.ID as id from EMPLOYEE_DETAILS pro where (emp.ID = pro.ID)))", sql);
    }

    @Test
    public void any_subquery() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);

        Root<Employee> root = query.from(Employee.class).as("tbl");
        CriteriaQuery<Employee> emp = cb.createQuery(Employee.class);
        Root<Employee> empRoot = query.from(Employee.class);
        //
        String sql = query
                .select(root)
                .where(
                        cb.gt(
                                root.get("id"), cb.any(emp.select(empRoot.get("id")).from(empRoot).where(cb.eq(empRoot.get("id"), 1L)))
                        )
                ).buildSelectQuery();
        assertEquals("select tbl.ENABLED as enabled,tbl.FIRST_NAME as firstName,tbl.ID as id,tbl.LAST_NAME as lastName,tbl.SALARY as salary from EMPLOYEES tbl where (tbl.ID > any (select EMPLOYEES.ID as id from EMPLOYEES EMPLOYEES where (EMPLOYEES.ID = 1)))", sql);
    }

    @Test
    public void all_subquery() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        CriteriaQuery<Employee> sub = cb.createQuery(Employee.class);
        Root<Employee> r = sub.from(Employee.class).as("sub");
        String sql = query
                .select(root)
                .where(
                        cb.ge(root.get("id"), cb.all(sub.select(r.get("id"))))
                ).buildSelectQuery();
        assertEquals("select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.ID >= all (select sub.ID as id from EMPLOYEES sub))", sql);
    }

    @Test
    public void scalar_select() {
        CriteriaQuery<Department> dep = cb.createQuery(Department.class);
        Root<Department> root = dep.from(Department.class);
        CriteriaQuery<Employee> emp = cb.createQuery(Employee.class);
        Root<Employee> empRoot = emp.from(Employee.class);
        String sql = dep.select(root.get("name"), cb.scalar(emp.select(cb.max(empRoot.get("salary"))))).buildSelectQuery();
        assertEquals("select (select max(EMPLOYEES.SALARY) from EMPLOYEES EMPLOYEES),DEPARTMENTS.NAME as name from DEPARTMENTS DEPARTMENTS", sql);
    }

    @Test
    void testLimitOffset() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> emp = query.from(Employee.class);

        query.select(emp).limit(5).offset(10);
        String sql = query.buildSelectQuery();
        assertEquals("select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES limit 5 offset 10", sql);

        query.limit(null).offset(null); // Test with null values
        sql = query.buildSelectQuery();
        assertEquals("select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES", sql); //no limit or offset


        query.limit(50).offset(null); //Just limit
        sql = query.buildSelectQuery();
        assertEquals("select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES limit 50", sql);


        query.limit(null).offset(150); //Offset
        sql = query.buildSelectQuery();
        assertEquals("select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES offset 150", sql);
    }


    @Test
    void testUnion() {
        CriteriaQuery<Employee> query1 = cb.createQuery(Employee.class);
        Root<Employee> emp1 = query1.from(Employee.class);
        query1
                .select(emp1)
                .where(cb.eq(emp1.get("departmentId"), 1));

        CriteriaQuery<Employee> query2 = cb.createQuery(Employee.class);
        Root<Employee> emp2 = query2.from(Employee.class);
        query2
                .select(emp2)
                .where(cb.eq(emp2.get("departmentId"), 2));

        String unionSql = query1.union(query2).buildSelectQuery();
        String expectedSql = "select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.departmentId = 1) union (select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.departmentId = 2))";
        assertEquals(expectedSql, unionSql);
    }

    @Test
    void testUnionAll() {
        CriteriaQuery<Employee> query1 = cb.createQuery(Employee.class);
        Root<Employee> emp1 = query1.from(Employee.class);
        query1
                .select(emp1)
                .where(cb.eq(emp1.get("departmentId"), 1));

        CriteriaQuery<Employee> query2 = cb.createQuery(Employee.class);
        Root<Employee> emp2 = query2.from(Employee.class);
        query2
                .select(emp2)
                .where(cb.eq(emp2.get("departmentId"), 2));

        String unionSql = query1.unionAll(query2).buildSelectQuery();
        String expectedSql = "select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.departmentId = 1) union all (select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.departmentId = 2))";
        assertEquals(expectedSql, unionSql);
    }

    @Test
    void testIntersect() {
        CriteriaQuery<Employee> query1 = cb.createQuery(Employee.class);
        Root<Employee> emp1 = query1.from(Employee.class);
        query1
                .select(emp1)
                .where(cb.eq(emp1.get("departmentId"), 1));

        CriteriaQuery<Employee> query2 = cb.createQuery(Employee.class);
        Root<Employee> emp2 = query2.from(Employee.class);
        query2
                .select(emp2)
                .where(cb.eq(emp2.get("departmentId"), 2));

        String intersectSql = query1.intersect(query2).buildSelectQuery();
        String expectedSql = "select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.departmentId = 1) intersect (select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.departmentId = 2))";

        assertEquals(expectedSql, intersectSql);
    }


    @Test
    void testExcept() {
        CriteriaQuery<Employee> query1 = cb.createQuery(Employee.class);
        Root<Employee> emp1 = query1.from(Employee.class);
        query1
                .select(emp1)
                .where(cb.eq(emp1.get("departmentId"), 1));

        CriteriaQuery<Employee> query2 = cb.createQuery(Employee.class);
        Root<Employee> emp2 = query2.from(Employee.class);
        query2
                .select(emp2)
                .where(cb.eq(emp2.get("departmentId"), 2));

        String exceptSql = query1.except(query2).buildSelectQuery();

        String expectedSql = "select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.departmentId = 1) except (select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.departmentId = 2))";
        assertEquals(expectedSql, exceptSql);
    }

    @Test
    void testDerivedTable() {

        CriteriaQuery<Department> query = cb.createQuery(Department.class);
        Root<Department> depRoot = query.from(Department.class).as("d");
        //
        CriteriaQuery<?> query1 = cb.createQuery(Employee.class); //
        Root<Employee> emp = query1.from(Employee.class).as("e");
        query1.select(emp)
                .where(cb.gt(emp.get("salary"), 1000));

        Subquery subquery = new Subquery(query1, new StandardDialect());
        subquery.setAlias("e");//alias overload
        query.select(depRoot.get("name"), emp.get("firstName"))
                .from(depRoot.rightJoin(subquery).on(cb.eq(depRoot.get("id"), emp.get("id"))));
        String sql = query.buildSelectQuery(); // Build the query from the outer query
        assertEquals("select e.FIRST_NAME as firstName,d.NAME as name from DEPARTMENTS d right join (select e.ENABLED as enabled,e.FIRST_NAME as firstName,e.ID as id,e.LAST_NAME as lastName,e.SALARY as salary from EMPLOYEES e where (e.SALARY > 1000)) e on d.ID = e.ID", sql);
    }

    @Test
    void testUnionAndIntersect() {
        CriteriaQuery<Employee> query1 = cb.createQuery(Employee.class);
        Root<Employee> emp1 = query1.from(Employee.class);
        query1
                .select(emp1)
                .where(cb.between(emp1.get("salary"), 0, 1300));

        CriteriaQuery<Employee> query2 = cb.createQuery(Employee.class);
        Root<Employee> emp2 = query2.from(Employee.class);
        query2
                .select(emp2)
                .where(cb.between(emp2.get("salary"), 1000, 6000));

        CriteriaQuery<Employee> query3 = cb.createQuery(Employee.class);
        Root<Employee> emp3 = query3.from(Employee.class);
        query3
                .select(emp3)
                .where(cb.gt(emp3.get("salary"), 1000));

        String combinedSql = query1
                .union(query2)
                .intersect(query3)
                .buildSelectQuery();
        String expectedSql = "select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.SALARY between 0 and 1300) union (select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.SALARY between 1000 and 6000)) intersect (select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.SALARY > 1000))";
        assertEquals(expectedSql, combinedSql);
    }

    @Test
    void testUnionAllAndExcept() {
        CriteriaQuery<EmployeeDetails> query1 = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> emp1 = query1.from(EmployeeDetails.class).as("det");
        query1
                .select(emp1)
                .where(cb.eq(emp1.get("departmentId"), 1));

        CriteriaQuery<EmployeeDetails> query2 = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> emp2 = query2.from(EmployeeDetails.class).as("det");
        query2
                .select(emp2)
                .where(cb.eq(emp2.get("departmentId"), 2));

        CriteriaQuery<EmployeeDetails> query3 = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> emp3 = query3.from(EmployeeDetails.class).as("det");
        query3
                .select(emp3)
                .where(cb.eq(emp3.get("departmentId"), 3));


        String combinedSql = query1.unionAll(query2).except(query3).buildSelectQuery();
        String expectedSql = "select det.DEPARTMENT_ID as departmentId,det.EMPLOYEE_ID as employeeId,det.ID as id from EMPLOYEE_DETAILS det where (det.DEPARTMENT_ID = 1) union all (select det.DEPARTMENT_ID as departmentId,det.EMPLOYEE_ID as employeeId,det.ID as id from EMPLOYEE_DETAILS det where (det.DEPARTMENT_ID = 2)) except (select det.DEPARTMENT_ID as departmentId,det.EMPLOYEE_ID as employeeId,det.ID as id from EMPLOYEE_DETAILS det where (det.DEPARTMENT_ID = 3))";
        assertEquals(expectedSql, combinedSql);
    }

    @Test
    void testIntersectAndUnion() {
        CriteriaQuery<EmployeeDetails> query1 = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> emp1 = query1.from(EmployeeDetails.class).as("det");
        query1
                .select(emp1)
                .where(cb.eq(emp1.get("departmentId"), 1));


        CriteriaQuery<EmployeeDetails> query2 = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> emp2 = query2.from(EmployeeDetails.class).as("det");
        query2
                .select(emp2)
                .where(cb.eq(emp2.get("departmentId"), 2));

        CriteriaQuery<EmployeeDetails> query3 = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> emp3 = query3.from(EmployeeDetails.class).as("det");
        query3
                .select(emp3)
                .where(cb.eq(emp3.get("departmentId"), 3));

        String combinedSql = query1.intersect(query2).union(query3).buildSelectQuery();
        String expectedSql = "select det.DEPARTMENT_ID as departmentId,det.EMPLOYEE_ID as employeeId,det.ID as id from EMPLOYEE_DETAILS det where (det.DEPARTMENT_ID = 1) intersect (select det.DEPARTMENT_ID as departmentId,det.EMPLOYEE_ID as employeeId,det.ID as id from EMPLOYEE_DETAILS det where (det.DEPARTMENT_ID = 2)) union (select det.DEPARTMENT_ID as departmentId,det.EMPLOYEE_ID as employeeId,det.ID as id from EMPLOYEE_DETAILS det where (det.DEPARTMENT_ID = 3))";
        assertEquals(expectedSql, combinedSql);
    }

    @Test
    void testEmbeddedUnion() {
        CriteriaQuery<EmployeeDetails> query1 = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> emp1 = query1.from(EmployeeDetails.class).as("det");
        query1
                .select(emp1)
                .where(cb.eq(emp1.get("departmentId"), 1));


        CriteriaQuery<EmployeeDetails> query2 = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> emp2 = query2.from(EmployeeDetails.class).as("det");
        query2
                .select(emp2)
                .where(cb.eq(emp2.get("departmentId"), 2));

        CriteriaQuery<EmployeeDetails> query3 = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> emp3 = query3.from(EmployeeDetails.class).as("det");
        query3
                .select(emp3)
                .where(cb.eq(emp3.get("departmentId"), 3));

        String combinedSql = query1.intersect(query2.union(query3)).buildSelectQuery();
        String expectedSql = "select det.DEPARTMENT_ID as departmentId,det.EMPLOYEE_ID as employeeId,det.ID as id from EMPLOYEE_DETAILS det where (det.DEPARTMENT_ID = 1) intersect (select det.DEPARTMENT_ID as departmentId,det.EMPLOYEE_ID as employeeId,det.ID as id from EMPLOYEE_DETAILS det where (det.DEPARTMENT_ID = 2) union (select det.DEPARTMENT_ID as departmentId,det.EMPLOYEE_ID as employeeId,det.ID as id from EMPLOYEE_DETAILS det where (det.DEPARTMENT_ID = 3)))";
        assertEquals(expectedSql, combinedSql);
    }

    @Test
    void testUnionWithOrderByAndLimit() {
        CriteriaQuery<EmployeeDetails> query1 = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> emp1 = query1.from(EmployeeDetails.class);
        query1
                .select(emp1)
                .where(cb.eq(emp1.get("departmentId"), 1));

        CriteriaQuery<EmployeeDetails> query2 = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> emp2 = query2.from(EmployeeDetails.class);
        query2
                .select(emp2)
                .where(cb.eq(emp2.get("departmentId"), 2));

        CriteriaQuery<EmployeeDetails> combinedQuery = query1.union(query2);
        combinedQuery
                .select()
                .orderBy(emp1.get("employeeId"), OrderDirection.ASC); // Order by first name
        combinedQuery.limit(10); // Limit to 10 results


        String sql = combinedQuery
                .buildSelectQuery();
        // ORDER BY and LIMIT should apply to the entire UNION
        String expectedSql = "select * from (select EMPLOYEE_DETAILS.DEPARTMENT_ID as departmentId,EMPLOYEE_DETAILS.EMPLOYEE_ID as employeeId,EMPLOYEE_DETAILS.ID as id from EMPLOYEE_DETAILS EMPLOYEE_DETAILS where (EMPLOYEE_DETAILS.DEPARTMENT_ID = 1) union (select EMPLOYEE_DETAILS.DEPARTMENT_ID as departmentId,EMPLOYEE_DETAILS.EMPLOYEE_ID as employeeId,EMPLOYEE_DETAILS.ID as id from EMPLOYEE_DETAILS EMPLOYEE_DETAILS where (EMPLOYEE_DETAILS.DEPARTMENT_ID = 2))) nested_query order by nested_query.employeeId ASC limit 10";
        assertEquals(expectedSql, sql);
    }


    @Test
    void testIntersectWithOrderByAndLimit() {

        CriteriaQuery<Employee> query1 = cb.createQuery(Employee.class);
        Root<Employee> emp1 = query1.from(Employee.class);
        query1
                .select(emp1)
                .where(cb.gt(emp1.get("salary"), 1000));

        CriteriaQuery<Employee> query2 = cb.createQuery(Employee.class);
        Root<Employee> emp2 = query2.from(Employee.class);
        query2
                .select(emp2)
                .where(cb.lt(emp2.get("salary"), 2000));

        CriteriaQuery<Employee> combinedQuery = query1.intersect(query2);
        combinedQuery.orderBy(emp1.get("firstName"), OrderDirection.ASC);
        combinedQuery.limit(5).offset(0);

        String sql = combinedQuery.buildSelectQuery();
        String expectedSql = "select * from (select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.SALARY > 1000) intersect (select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.SALARY < 2000))) nested_query order by nested_query.firstName ASC limit 5 offset 0";
        assertEquals(expectedSql, sql);
    }


    @Test
    void testExceptWithOrderByAndLimit() {

        CriteriaQuery<EmployeeDetails> query1 = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> emp1 = query1.from(EmployeeDetails.class);
        query1
                .select(emp1)
                .where(cb.eq(emp1.get("departmentId"), 1));

        CriteriaQuery<EmployeeDetails> query2 = cb.createQuery(EmployeeDetails.class);
        Root<EmployeeDetails> emp2 = query2.from(EmployeeDetails.class);
        query2
                .select(emp2)
                .where(cb.eq(emp2.get("departmentId"), 2));


        CriteriaQuery<EmployeeDetails> combinedQuery = query1.except(query2);
        combinedQuery.orderBy(emp1.get("employeeId"), OrderDirection.ASC);
        combinedQuery.limit(50);

        String sql = combinedQuery.buildSelectQuery();
        String expectedSql = "select * from (select EMPLOYEE_DETAILS.DEPARTMENT_ID as departmentId,EMPLOYEE_DETAILS.EMPLOYEE_ID as employeeId,EMPLOYEE_DETAILS.ID as id from EMPLOYEE_DETAILS EMPLOYEE_DETAILS where (EMPLOYEE_DETAILS.DEPARTMENT_ID = 1) except (select EMPLOYEE_DETAILS.DEPARTMENT_ID as departmentId,EMPLOYEE_DETAILS.EMPLOYEE_ID as employeeId,EMPLOYEE_DETAILS.ID as id from EMPLOYEE_DETAILS EMPLOYEE_DETAILS where (EMPLOYEE_DETAILS.DEPARTMENT_ID = 2))) nested_query order by nested_query.employeeId ASC limit 50";

        assertEquals(expectedSql, sql);
    }

    @Test
    void testCorrelatedSubquery() {
        CriteriaQuery<Department> query = cb.createQuery(Department.class);
        Root<Department> dep = query.from(Department.class);

        CriteriaQuery<Employee> subquery = cb.createQuery(Employee.class);  // Assuming you have a subquery method
        Root<Employee> emp = subquery.from(Employee.class);
        subquery
                .select(emp.get("salary")).where(cb.eq(emp.get("departmentId"), dep.get("id"))); // Correlating condition

        query.select(dep).where(cb.gt(dep.get("budget"), new Subquery(subquery, new StandardDialect()))); // Using the correlated subquery

        String expectedSql = "select DEPARTMENTS.ID as id,DEPARTMENTS.LOCATION as location,DEPARTMENTS.NAME as name from DEPARTMENTS DEPARTMENTS where (DEPARTMENTS.budget > (select EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES where (EMPLOYEES.departmentId = DEPARTMENTS.ID)) )";  // Verify correct correlation
        assertEquals(expectedSql, query.buildSelectQuery());
    }

    @Test
    void simple_case() {
        CriteriaBuilder cb = new CriteriaBuilder();
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> emp = query.from(Employee.class).as("tbl");
        String sql = query
                .select(
                        emp.get("firstName"),
                        cb.choice(emp.get("salary"))
                                .when(100)
                                .then("slave")
                                .when(200)
                                .then("employee")
                                .otherwise("rich")
                                .as("status")
                ).from(emp)
                .buildSelectQuery();

        assertEquals("select tbl.FIRST_NAME as firstName,case tbl.SALARY when 100 then 'slave' when 200 then 'employee' else 'rich' end as status from EMPLOYEES tbl", sql);
    }

    @Test
    void searched_case() {
        CriteriaBuilder cb = new CriteriaBuilder();
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> emp = query.from(Employee.class).as("tbl");
        String sql = query
                .select(
                        emp.get("firstName"),
                        cb.choice()
                                .whenThen(cb.eq(emp.get("salary"), 100), "slave")
                                .when(cb.eq(emp.get("salary"), 200))
                                .then("employee")
                                .otherwise("rich")
                                .as("status")
                ).from(emp)
                .buildSelectQuery();
        assertEquals("select tbl.FIRST_NAME as firstName,case when tbl.SALARY = 100 then 'slave' when tbl.SALARY = 200 then 'employee' else 'rich' end as status from EMPLOYEES tbl", sql);
    }

    @Test
    void nested_case() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> emp = query.from(Employee.class);
        Selectable outerCase = cb.choice()
                .when(cb.gt(emp.get("age"), 60))
                .then("Retired")
                .otherwise(
                        cb.choice(emp.get("departmentId"))  // Inner Simple CASE
                                .when(1)
                                .then("Sales")
                                .whenThen(2, "Marketing")
                                .otherwise("Other")

                ).end().as("status");
        String sql = query.select(outerCase).buildSelectQuery();
        assertEquals("select case when EMPLOYEES.age > 60 then 'Retired' else case EMPLOYEES.departmentId when 1 then 'Sales' when 2 then 'Marketing' else 'Other' end end as status from EMPLOYEES EMPLOYEES", sql);
    }

    @Test
    void simple_cte() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> root = cr.from(Employee.class);
        Cte<?> cte = cb.with("my_query").as(
                cr.select()
                        .from(root)
        );
        String sql = cte
                .select(cte.get("firstName"))
                .from(cte)
                .buildSelectQuery();
        assertEquals("with my_query as (select EMPLOYEES.ENABLED as enabled,EMPLOYEES.FIRST_NAME as firstName,EMPLOYEES.ID as id,EMPLOYEES.LAST_NAME as lastName,EMPLOYEES.SALARY as salary from EMPLOYEES EMPLOYEES) select my_query.firstName as firstName from my_query my_query", sql);
    }

    /**
     * with my_query as (select sum(EMPLOYEES.salary) as salary, EMPLOYEES.last_name as lastName
     * from EMPLOYEES EMPLOYEES
     * group by last_name)
     * select my_query.salary as salary, my_query.lastName as lastName
     * from my_query my_query
     */

    @Test
    void complex_cte() {
        CriteriaQuery<Employee> cr = cb.createQuery(Employee.class);
        Root<Employee> root = cr.from(Employee.class);
        Cte<?> cte = cb.with("my_query").as(
                cr.select(cb.sum(root.get("salary")).as("salary"), root.get("lastName"))
                        .from(root)
                        .groupBy(root.get("lastName"))
        );
        String sql = cte
                .select(cte.get("lastName"), cte.get("salary"))
                .from(cte)
                .buildSelectQuery();
        assertEquals("with my_query as (select EMPLOYEES.LAST_NAME as lastName,sum(EMPLOYEES.SALARY) as salary from EMPLOYEES EMPLOYEES group by EMPLOYEES.LAST_NAME) select my_query.lastName as lastName,my_query.salary as salary from my_query my_query", sql);
    }


    @Test
    void testJoinWithComplexSubqueryCondition() {
        CriteriaBuilder cb = new CriteriaBuilder();
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> emp = query.from(Employee.class).as("e");
        Root<Department> dept = query.from(Department.class).as("d");

        CriteriaQuery<Employee> subquery1 = cb.createQuery(Employee.class);
        Root<Employee> sqEmp1 = subquery1.from(Employee.class).as("sqe1");
        subquery1.select(sqEmp1.get("departmentId"))
                .where(cb.gt(sqEmp1.get("salary"), 50000));

        CriteriaQuery<Department> subquery2 = cb.createQuery(Department.class);
        Root<Department> sqDept = subquery2.from(Department.class).as("sqd");
        subquery2.select(sqDept.get("id"))
                .where(cb.like(sqDept.get("name"), "%Engineering%"));


        query.select(emp)
                .from(emp.innerJoin(dept)
                        .on(
                                cb.and(
                                        cb.in(dept.get("id"), new Subquery(subquery1, cb.getSqlDialect())),  // Subquery in IN clause
                                        cb.not(cb.in(dept.get("id"), new Subquery(subquery2, cb.getSqlDialect()))) // Subquery in NOT IN clause, combined with NOT
                                )
                        ));


        String expectedSql = "select e.ENABLED as enabled,e.FIRST_NAME as firstName,e.ID as id,e.LAST_NAME as lastName,e.SALARY as salary from EMPLOYEES e inner join DEPARTMENTS d on (d.ID in ( (select sqe1.departmentId as departmentId from EMPLOYEES sqe1 where (sqe1.SALARY > 50000)) ) and not ((d.ID in ( (select sqd.ID as id from DEPARTMENTS sqd where (sqd.NAME like '%%Engineering%%')) ))))";
        assertEquals(expectedSql, query.buildSelectQuery());

    }

    @Test
    void testCaseWithNullHandling() {
        CriteriaBuilder cb = new CriteriaBuilder();
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> emp = query.from(Employee.class).as("tbl");

        // Test NULL handling in WHEN clauses
        Selectable caseExpression = cb.choice(emp.get("departmentId"))
                .when(null).then("Unknown Department")       // WHEN departmentId IS NULL
                .when(1).then("Sales")
                .otherwise("Other").as("departmentName");

        String sql = query.select(caseExpression).buildSelectQuery();
        assertEquals("select case tbl.departmentId when null then 'Unknown Department' when 1 then 'Sales' else 'Other' end as departmentName from EMPLOYEES tbl", sql);


        // Test NULL handling with IS NULL predicate in WHEN clause (Searched CASE)
        caseExpression = cb.choice()
                .when(cb.isNull(emp.get("departmentId"))).then("No Department Assigned")
                .when(cb.eq(emp.get("departmentId"), 1)).then("Sales")
                .otherwise("Other");
        sql = query.select(caseExpression).buildSelectQuery();

        assertEquals("select case when tbl.departmentId is null then 'No Department Assigned' when tbl.departmentId = 1 then 'Sales' else 'Other' end from EMPLOYEES tbl", sql);

    }

    @Test
    void should_generate_named_update_query() {
        CriteriaBuilder cb = new CriteriaBuilder();
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> emp = query.from(Employee.class).as("tbl");
        String sql = query
                .select(emp)
                .from(emp)
                .where(cb.eq(emp.get("id"), 1))
                .buildNamedUpdateQuery();
        assertEquals("update EMPLOYEES tbl set ENABLED = :enabled, FIRST_NAME = :firstName, ID = :id, LAST_NAME = :lastName, SALARY = :salary", sql);
    }

    @Test
    void sum_over() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        query.select(
                        cb.sum(root.get("salary"))
                                .over()
                                .partitionBy(root.get("departmentId"))
                                .as("sum")
                )
                .from(root);
        String sql = query.buildSelectQuery();
        assertEquals("select sum(EMPLOYEES.SALARY) over (partition by EMPLOYEES.departmentId) as sum from EMPLOYEES EMPLOYEES", sql);
    }

    @Test
    void rank() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        query.select(
                        cb.rank()
                                .over()
                                .partitionBy(root.get("departmentId"))
                                .orderBy(root.get("salary").asc())
                                .as("ranking")
                )
                .from(root);
        String sql = query.buildSelectQuery();
        assertEquals("select rank() over (partition by EMPLOYEES.departmentId order by EMPLOYEES.SALARY ASC) as ranking from EMPLOYEES EMPLOYEES", sql);
    }

    @Test
    void row_number() {
        CriteriaQuery<Employee> query = cb.createQuery(Employee.class);
        Root<Employee> root = query.from(Employee.class);
        String sql = cb.rowNumber().over().partitionBy(root.get("departmentId")).orderBy(root.get("salary").asc()).toSql();
        assertEquals("row_number() over (partition by EMPLOYEES.departmentId order by EMPLOYEES.SALARY ASC)", sql);
    }


}
package com.ainouss.jdatatools.query.model;


import jakarta.persistence.Column;
import jakarta.persistence.Table;
import lombok.Data;

@Data
@Table(name = "DEPARTMENTS")
public class Department {

    @Column(name = "ID")
    private Long id;

    @Column(name = "NAME")
    private String name;

    @Column(name = "LOCATION")
    private String location;
}

package com.ainouss.jdatatools.query.model;

import jakarta.persistence.Column;
import jakarta.persistence.Table;
import lombok.Data;

@Data
@Table(name = "EMPLOYEES")
public class Employee {

    @Column(name = "ID")
    private Long id;

    @Column(name = "FIRST_NAME")
    private String firstName;

    @Column(name = "LAST_NAME")
    private String lastName;

    @Column(name = "SALARY")
    private int salary;

    @Column(name = "ENABLED")
    private String enabled;

}

package com.ainouss.jdatatools.query.model;

import jakarta.persistence.Column;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Table(name = "EMPLOYEE_DETAILS")
public class EmployeeDetails {

    @Id
    @Column(name = "ID")
    private Integer id;

    @Column(name = "EMPLOYEE_ID")
    private Integer employeeId;

    @Column(name = "DEPARTMENT_ID")
    private Integer departmentId;
}

